{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to cropengine","text":"<p>cropengine is a Python package that streamlines running process-based crop models by automating data preparation, simulation workflows, and result analysis.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://geonextgis.github.io/cropengine</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"agromanagement/","title":"agromanagement module","text":"<p>Module to setup agromanagement</p>"},{"location":"agromanagement/#cropengine.agromanagement.WOFOSTAgroEventBuilder","title":"<code> WOFOSTAgroEventBuilder        </code>","text":"<p>Helper class to build PCSE agromanagement events using a YAML schema for validation.</p> Source code in <code>cropengine/agromanagement.py</code> <pre><code>class WOFOSTAgroEventBuilder:\n    \"\"\"\n    Helper class to build PCSE agromanagement events using a YAML schema for validation.\n    \"\"\"\n\n    def __init__(self):\n        try:\n            with pkg_resources.files(configs).joinpath(\"agromanagement.yaml\").open(\n                \"r\"\n            ) as f:\n                self.schema = yaml.safe_load(f)[\"wofost\"]\n        except Exception as e:\n            raise RuntimeError(f\"Failed to load agromanagement.yaml: {e}\")\n\n    def get_timed_events_info(self):\n        return self.schema[\"TimedEvents\"]\n\n    def get_state_events_info(self):\n        return self.schema[\"StateEvents\"]\n\n    def _convert_date(\n        self, date_val: Union[str, datetime.date, None]\n    ) -&gt; Optional[datetime.date]:\n        \"\"\"Helper to convert string dates to datetime.date objects.\"\"\"\n        if date_val is None:\n            return None\n        if isinstance(date_val, str):\n            return datetime.datetime.strptime(date_val, \"%Y-%m-%d\").date()\n        if isinstance(date_val, (datetime.date, datetime.datetime)):\n            return date_val\n        raise ValueError(\n            f\"Invalid date format: {date_val}. Expected YYYY-MM-DD string or datetime.date object.\"\n        )\n\n    def create_timed_events(self, signal_type: str, events_list: List[Dict]) -&gt; dict:\n        \"\"\"\n        Creates a single TimedEvent dictionary containing a LIST of dates.\n        \"\"\"\n        if signal_type not in self.schema[\"TimedEvents\"]:\n            raise ValueError(f\"Unknown TimedEvent signal: {signal_type}\")\n\n        schema_def = self.schema[\"TimedEvents\"][signal_type]\n        required_params = schema_def[\"events_table\"].keys()\n\n        populated_events_list = []\n\n        for entry in events_list:\n            current_date = self._convert_date(entry[\"event_date\"])\n\n            params = {}\n            for param in required_params:\n                params[param] = entry[param]\n\n            populated_events_list.append({current_date: params})\n\n        return {\n            \"event_signal\": signal_type,\n            \"name\": schema_def.get(\"name\"),\n            \"comment\": schema_def.get(\"comment\"),\n            \"events_table\": populated_events_list,\n        }\n\n    def create_state_events(\n        self,\n        signal_type: str,\n        state_var: str,\n        zero_condition: str,\n        events_list: List[Dict],\n    ) -&gt; dict:\n        \"\"\"\n        Creates a single StateEvent dictionary containing a LIST of thresholds.\n        \"\"\"\n        if signal_type not in self.schema[\"StateEvents\"]:\n            raise ValueError(f\"Unknown StateEvent signal: {signal_type}\")\n\n        schema_def = self.schema[\"StateEvents\"][signal_type]\n        required_params = schema_def[\"events_table\"].keys()\n\n        # Change: Use a LIST for the events table\n        populated_events_list = []\n\n        for entry in events_list:\n            threshold = entry[\"threshold\"]\n\n            params = {}\n            for param in required_params:\n                params[param] = entry[param]\n\n            # Append as a single-key dictionary to the list\n            populated_events_list.append({threshold: params})\n\n        return {\n            \"event_signal\": signal_type,\n            \"event_state\": state_var,\n            \"zero_condition\": zero_condition,\n            \"name\": schema_def.get(\"name\"),\n            \"comment\": schema_def.get(\"comment\"),\n            \"events_table\": populated_events_list,\n        }\n</code></pre>"},{"location":"agromanagement/#cropengine.agromanagement.WOFOSTAgroEventBuilder.create_state_events","title":"<code>create_state_events(self, signal_type, state_var, zero_condition, events_list)</code>","text":"<p>Creates a single StateEvent dictionary containing a LIST of thresholds.</p> Source code in <code>cropengine/agromanagement.py</code> <pre><code>def create_state_events(\n    self,\n    signal_type: str,\n    state_var: str,\n    zero_condition: str,\n    events_list: List[Dict],\n) -&gt; dict:\n    \"\"\"\n    Creates a single StateEvent dictionary containing a LIST of thresholds.\n    \"\"\"\n    if signal_type not in self.schema[\"StateEvents\"]:\n        raise ValueError(f\"Unknown StateEvent signal: {signal_type}\")\n\n    schema_def = self.schema[\"StateEvents\"][signal_type]\n    required_params = schema_def[\"events_table\"].keys()\n\n    # Change: Use a LIST for the events table\n    populated_events_list = []\n\n    for entry in events_list:\n        threshold = entry[\"threshold\"]\n\n        params = {}\n        for param in required_params:\n            params[param] = entry[param]\n\n        # Append as a single-key dictionary to the list\n        populated_events_list.append({threshold: params})\n\n    return {\n        \"event_signal\": signal_type,\n        \"event_state\": state_var,\n        \"zero_condition\": zero_condition,\n        \"name\": schema_def.get(\"name\"),\n        \"comment\": schema_def.get(\"comment\"),\n        \"events_table\": populated_events_list,\n    }\n</code></pre>"},{"location":"agromanagement/#cropengine.agromanagement.WOFOSTAgroEventBuilder.create_timed_events","title":"<code>create_timed_events(self, signal_type, events_list)</code>","text":"<p>Creates a single TimedEvent dictionary containing a LIST of dates.</p> Source code in <code>cropengine/agromanagement.py</code> <pre><code>def create_timed_events(self, signal_type: str, events_list: List[Dict]) -&gt; dict:\n    \"\"\"\n    Creates a single TimedEvent dictionary containing a LIST of dates.\n    \"\"\"\n    if signal_type not in self.schema[\"TimedEvents\"]:\n        raise ValueError(f\"Unknown TimedEvent signal: {signal_type}\")\n\n    schema_def = self.schema[\"TimedEvents\"][signal_type]\n    required_params = schema_def[\"events_table\"].keys()\n\n    populated_events_list = []\n\n    for entry in events_list:\n        current_date = self._convert_date(entry[\"event_date\"])\n\n        params = {}\n        for param in required_params:\n            params[param] = entry[param]\n\n        populated_events_list.append({current_date: params})\n\n    return {\n        \"event_signal\": signal_type,\n        \"name\": schema_def.get(\"name\"),\n        \"comment\": schema_def.get(\"comment\"),\n        \"events_table\": populated_events_list,\n    }\n</code></pre>"},{"location":"agromanagement/#cropengine.agromanagement.WOFOSTAgroManagementProvider","title":"<code> WOFOSTAgroManagementProvider            (list)         </code>","text":"<p>A dynamic provider for WOFOST AgroManagement. Generates a rotation of crops based on start/end dates and handles YAML serialization.</p> Source code in <code>cropengine/agromanagement.py</code> <pre><code>class WOFOSTAgroManagementProvider(list):\n    \"\"\"\n    A dynamic provider for WOFOST AgroManagement.\n    Generates a rotation of crops based on start/end dates and handles YAML serialization.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n    def _convert_date(\n        self, date_val: Union[str, datetime.date, None]\n    ) -&gt; Optional[datetime.date]:\n        \"\"\"Helper to convert string dates to datetime.date objects.\"\"\"\n        if date_val is None:\n            return None\n        if isinstance(date_val, str):\n            return datetime.datetime.strptime(date_val, \"%Y-%m-%d\").date()\n        if isinstance(date_val, (datetime.date, datetime.datetime)):\n            return date_val\n        raise ValueError(\n            f\"Invalid date format: {date_val}. Expected YYYY-MM-DD string or datetime.date object.\"\n        )\n\n    def add_campaign(\n        self,\n        campaign_start_date: Union[str, datetime.date],\n        campaign_end_date: Union[str, datetime.date],\n        crop_name: str,\n        variety_name: str,\n        crop_start_date: Union[str, datetime.date],\n        crop_end_date: Optional[Union[str, datetime.date]] = None,\n        crop_start_type: str = \"sowing\",\n        crop_end_type: str = \"maturity\",\n        max_duration: int = 300,\n        timed_events: List[Dict] = None,\n        state_events: List[Dict] = None,\n    ):\n        \"\"\"\n        Adds a single cropping campaign to the rotation.\n\n        Args:\n            campaign_start_date: Start date of the campaign (str 'YYYY-MM-DD' or date object).\n            campaign_end_date: End date of the campaign (str 'YYYY-MM-DD' or date object).\n            crop_name: Name of the crop (e.g., 'wheat').\n            variety_name: Variety identifier (e.g., 'winter-wheat').\n            crop_start_date: Date of sowing or emergence (str 'YYYY-MM-DD' or date object).\n            crop_end_date: Optional harvest date (str 'YYYY-MM-DD' or date object).\n            crop_start_type: 'sowing' or 'emergence'.\n            crop_end_type: 'maturity', 'harvest', or 'earliest'.\n            max_duration: Maximum duration of the crop cycle in days.\n            timed_events: List of timed event dictionaries (from EventBuilder).\n            state_events: List of state event dictionaries (from EventBuilder).\n        \"\"\"\n        # Convert inputs to ensure they are date objects or valid strings\n        c_start = self._convert_date(campaign_start_date)\n        c_end = self._convert_date(campaign_end_date)\n        crop_start = self._convert_date(crop_start_date)\n        crop_end = self._convert_date(crop_end_date)\n\n        self._last_campaign_end = c_end\n\n        campaign_config = {\n            \"CropCalendar\": {\n                \"crop_name\": crop_name,\n                \"variety_name\": variety_name,\n                \"crop_start_date\": crop_start,\n                \"crop_start_type\": crop_start_type,\n                \"crop_end_date\": crop_end,\n                \"crop_end_type\": crop_end_type,\n                \"max_duration\": max_duration,\n            },\n            \"TimedEvents\": timed_events if timed_events else None,\n            \"StateEvents\": state_events if state_events else None,\n        }\n\n        # Append the campaign dictionary {start_date: config} to the list\n        self.append({c_start: campaign_config})\n\n    def add_trailing_empty_campaign(self):\n        \"\"\"\n        Adds a final empty campaign to ensure the simulation runs until the very end\n        of the requested period.\n\n        Args:\n            start_date: Start date of the empty period (str 'YYYY-MM-DD' or date object).\n        \"\"\"\n        if self._last_campaign_end is None:\n            raise RuntimeError(\n                \"Cannot add trailing empty campaign before adding at least one campaign.\"\n            )\n\n        self.append({self._last_campaign_end: None})\n\n    def save_to_yaml(self, filename: str):\n        \"\"\"\n        Exports the current agromanagement configuration to a YAML file.\n\n        Structure matches the PCSE requirement:\n        AgroManagement:\n        - Date:\n            CropCalendar: ...\n            TimedEvents: ...\n        \"\"\"\n        # Wrap the list in the root 'AgroManagement' key\n        output_structure = {\"AgroManagement\": list(self)}\n\n        with open(filename, \"w\") as f:\n            yaml.dump(output_structure, f, sort_keys=False)\n</code></pre>"},{"location":"agromanagement/#cropengine.agromanagement.WOFOSTAgroManagementProvider.add_campaign","title":"<code>add_campaign(self, campaign_start_date, campaign_end_date, crop_name, variety_name, crop_start_date, crop_end_date=None, crop_start_type='sowing', crop_end_type='maturity', max_duration=300, timed_events=None, state_events=None)</code>","text":"<p>Adds a single cropping campaign to the rotation.</p> <p>Parameters:</p> Name Type Description Default <code>campaign_start_date</code> <code>Union[str, datetime.date]</code> <p>Start date of the campaign (str 'YYYY-MM-DD' or date object).</p> required <code>campaign_end_date</code> <code>Union[str, datetime.date]</code> <p>End date of the campaign (str 'YYYY-MM-DD' or date object).</p> required <code>crop_name</code> <code>str</code> <p>Name of the crop (e.g., 'wheat').</p> required <code>variety_name</code> <code>str</code> <p>Variety identifier (e.g., 'winter-wheat').</p> required <code>crop_start_date</code> <code>Union[str, datetime.date]</code> <p>Date of sowing or emergence (str 'YYYY-MM-DD' or date object).</p> required <code>crop_end_date</code> <code>Union[str, datetime.date]</code> <p>Optional harvest date (str 'YYYY-MM-DD' or date object).</p> <code>None</code> <code>crop_start_type</code> <code>str</code> <p>'sowing' or 'emergence'.</p> <code>'sowing'</code> <code>crop_end_type</code> <code>str</code> <p>'maturity', 'harvest', or 'earliest'.</p> <code>'maturity'</code> <code>max_duration</code> <code>int</code> <p>Maximum duration of the crop cycle in days.</p> <code>300</code> <code>timed_events</code> <code>List[Dict]</code> <p>List of timed event dictionaries (from EventBuilder).</p> <code>None</code> <code>state_events</code> <code>List[Dict]</code> <p>List of state event dictionaries (from EventBuilder).</p> <code>None</code> Source code in <code>cropengine/agromanagement.py</code> <pre><code>def add_campaign(\n    self,\n    campaign_start_date: Union[str, datetime.date],\n    campaign_end_date: Union[str, datetime.date],\n    crop_name: str,\n    variety_name: str,\n    crop_start_date: Union[str, datetime.date],\n    crop_end_date: Optional[Union[str, datetime.date]] = None,\n    crop_start_type: str = \"sowing\",\n    crop_end_type: str = \"maturity\",\n    max_duration: int = 300,\n    timed_events: List[Dict] = None,\n    state_events: List[Dict] = None,\n):\n    \"\"\"\n    Adds a single cropping campaign to the rotation.\n\n    Args:\n        campaign_start_date: Start date of the campaign (str 'YYYY-MM-DD' or date object).\n        campaign_end_date: End date of the campaign (str 'YYYY-MM-DD' or date object).\n        crop_name: Name of the crop (e.g., 'wheat').\n        variety_name: Variety identifier (e.g., 'winter-wheat').\n        crop_start_date: Date of sowing or emergence (str 'YYYY-MM-DD' or date object).\n        crop_end_date: Optional harvest date (str 'YYYY-MM-DD' or date object).\n        crop_start_type: 'sowing' or 'emergence'.\n        crop_end_type: 'maturity', 'harvest', or 'earliest'.\n        max_duration: Maximum duration of the crop cycle in days.\n        timed_events: List of timed event dictionaries (from EventBuilder).\n        state_events: List of state event dictionaries (from EventBuilder).\n    \"\"\"\n    # Convert inputs to ensure they are date objects or valid strings\n    c_start = self._convert_date(campaign_start_date)\n    c_end = self._convert_date(campaign_end_date)\n    crop_start = self._convert_date(crop_start_date)\n    crop_end = self._convert_date(crop_end_date)\n\n    self._last_campaign_end = c_end\n\n    campaign_config = {\n        \"CropCalendar\": {\n            \"crop_name\": crop_name,\n            \"variety_name\": variety_name,\n            \"crop_start_date\": crop_start,\n            \"crop_start_type\": crop_start_type,\n            \"crop_end_date\": crop_end,\n            \"crop_end_type\": crop_end_type,\n            \"max_duration\": max_duration,\n        },\n        \"TimedEvents\": timed_events if timed_events else None,\n        \"StateEvents\": state_events if state_events else None,\n    }\n\n    # Append the campaign dictionary {start_date: config} to the list\n    self.append({c_start: campaign_config})\n</code></pre>"},{"location":"agromanagement/#cropengine.agromanagement.WOFOSTAgroManagementProvider.add_trailing_empty_campaign","title":"<code>add_trailing_empty_campaign(self)</code>","text":"<p>Adds a final empty campaign to ensure the simulation runs until the very end of the requested period.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <p>Start date of the empty period (str 'YYYY-MM-DD' or date object).</p> required Source code in <code>cropengine/agromanagement.py</code> <pre><code>def add_trailing_empty_campaign(self):\n    \"\"\"\n    Adds a final empty campaign to ensure the simulation runs until the very end\n    of the requested period.\n\n    Args:\n        start_date: Start date of the empty period (str 'YYYY-MM-DD' or date object).\n    \"\"\"\n    if self._last_campaign_end is None:\n        raise RuntimeError(\n            \"Cannot add trailing empty campaign before adding at least one campaign.\"\n        )\n\n    self.append({self._last_campaign_end: None})\n</code></pre>"},{"location":"agromanagement/#cropengine.agromanagement.WOFOSTAgroManagementProvider.save_to_yaml","title":"<code>save_to_yaml(self, filename)</code>","text":"<p>Exports the current agromanagement configuration to a YAML file.</p> <p>Structure matches the PCSE requirement: AgroManagement: - Date:     CropCalendar: ...     TimedEvents: ...</p> Source code in <code>cropengine/agromanagement.py</code> <pre><code>def save_to_yaml(self, filename: str):\n    \"\"\"\n    Exports the current agromanagement configuration to a YAML file.\n\n    Structure matches the PCSE requirement:\n    AgroManagement:\n    - Date:\n        CropCalendar: ...\n        TimedEvents: ...\n    \"\"\"\n    # Wrap the list in the root 'AgroManagement' key\n    output_structure = {\"AgroManagement\": list(self)}\n\n    with open(filename, \"w\") as f:\n        yaml.dump(output_structure, f, sort_keys=False)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/geonextgis/cropengine/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>cropengine could always use more documentation, whether as part of the official cropengine docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/geonextgis/cropengine/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up cropengine for local development.</p> <ol> <li> <p>Fork the cropengine repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/cropengine.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv cropengine\n$ cd cropengine/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 cropengine tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/geonextgis/cropengine/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"conversions/","title":"conversions module","text":""},{"location":"conversions/#cropengine.conversions.Td_to_VAP","title":"<code>Td_to_VAP(dewpoint_K)</code>","text":"<p>Compute vapour pressure (hPa) from dewpoint temperature (K).</p> Source code in <code>cropengine/conversions.py</code> <pre><code>def Td_to_VAP(dewpoint_K):\n    \"\"\"Compute vapour pressure (hPa) from dewpoint temperature (K).\"\"\"\n    # Handle Series or scalar\n    Td_C = dewpoint_K - 273.15\n    vap_kPa = 0.6108 * np.exp((17.27 * Td_C) / (Td_C + 237.3))\n    return vap_kPa\n</code></pre>"},{"location":"conversions/#cropengine.conversions.uv_to_wind","title":"<code>uv_to_wind(u, v)</code>","text":"<p>Compute wind speed magnitude (m/s).</p> Source code in <code>cropengine/conversions.py</code> <pre><code>def uv_to_wind(u, v):\n    \"\"\"Compute wind speed magnitude (m/s).\"\"\"\n    return np.sqrt(u**2 + v**2)\n</code></pre>"},{"location":"crop/","title":"crop module","text":"<p>Module to prepare crop parameters</p>"},{"location":"crop/#cropengine.crop.WOFOSTCropParametersProvider","title":"<code> WOFOSTCropParametersProvider            (YAMLCropDataProvider)         </code>","text":"<p>A data provider for WOFOST crop parameters. This class extends the standard YAMLCropDataProvider to automatically locate and load crop-specific parameter files.</p> <p>Parameters:</p> Name Type Description Default <code>crop_name</code> <code>str</code> <p>The name of the crop (e.g., 'wheat', 'maize').</p> required <code>variety_name</code> <code>str</code> <p>The specific variety of the crop (e.g., 'Winter_wheat_101').</p> required Source code in <code>cropengine/crop.py</code> <pre><code>class WOFOSTCropParametersProvider(YAMLCropDataProvider):\n    \"\"\"\n    A data provider for WOFOST crop parameters. This class extends the standard YAMLCropDataProvider to automatically\n    locate and load crop-specific parameter files.\n\n    Args:\n        crop_name (str): The name of the crop (e.g., 'wheat', 'maize').\n        variety_name (str): The specific variety of the crop (e.g., 'Winter_wheat_101').\n    \"\"\"\n\n    def __init__(self, crop_name: str, variety_name: str):\n        # 1. Get the directory path directly from the module\n        config_path = list(wofost_crop_params.__path__)[0]\n\n        # 2. Initialize the parent class with the string path\n        super().__init__(fpath=str(config_path))\n\n        # 3. Set the active crop\n        self.set_active_crop(crop_name, variety_name)\n        self.crop_name = crop_name\n        self.variety_name = variety_name\n        self.param_metadata = self._get_param_metadata()\n\n    def _get_param_metadata(self) -&gt; list[dict]:\n        \"\"\"\n        Retrieves metadata for the current crop variety from the YAML configuration.\n        \"\"\"\n        with pkg_resources.files(wofost_crop_params).joinpath(\n            f\"{self.crop_name}.yaml\"\n        ).open(\"r\") as f:\n            crop_config = yaml.safe_load(f)\n            crop_variety_config = crop_config[\"CropParameters\"][\"Varieties\"][\n                self.variety_name\n            ]\n\n            param_metadata = []\n            for param, info in crop_variety_config.items():\n                try:\n                    param_dict = {\n                        \"parameter\": param,\n                        \"description\": info[1],\n                        \"unit\": info[-1][0] if len(info[-1]) == 1 else info[-1],\n                        \"default\": info[0],\n                    }\n                    param_metadata.append(param_dict)\n                except (IndexError, TypeError, KeyError):\n                    continue\n\n            return param_metadata\n</code></pre>"},{"location":"crop/#cropengine.crop.get_available_crop_varieties","title":"<code>get_available_crop_varieties(model, crop)</code>","text":"<p>Retrieves available varieties and their metadata for a specific crop.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The name of the simulation model.</p> required <code>crop</code> <code>str</code> <p>The name of the crop (e.g., 'wheat').</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>A dictionary where keys are variety identifiers and values are metadata strings (descriptions). Returns None if the model is not supported.</p> Source code in <code>cropengine/crop.py</code> <pre><code>def get_available_crop_varieties(model: str, crop: str) -&gt; dict | None:\n    \"\"\"\n    Retrieves available varieties and their metadata for a specific crop.\n\n    Args:\n        model (str): The name of the simulation model.\n        crop (str): The name of the crop (e.g., 'wheat').\n\n    Returns:\n        dict | None: A dictionary where keys are variety identifiers and values\n        are metadata strings (descriptions). Returns None if the model is not supported.\n    \"\"\"\n    if model.startswith(\"Wofost\"):\n        with pkg_resources.files(wofost_crop_params).joinpath(f\"{crop}.yaml\").open(\n            \"r\"\n        ) as f:\n            crop_config = yaml.safe_load(f)\n\n            all_crop_varieties = crop_config[\"CropParameters\"][\"Varieties\"].keys()\n            crop_varieties = {}\n\n            for v in all_crop_varieties:\n                # Extract the descriptive metadata for the variety\n                meta = crop_config[\"CropParameters\"][\"Varieties\"][v][\"Metadata\"]\n                crop_varieties[v] = meta\n\n        return crop_varieties\n\n    else:\n        return None\n</code></pre>"},{"location":"crop/#cropengine.crop.get_available_crops","title":"<code>get_available_crops(model)</code>","text":"<p>Retrieves a list of supported crops for a specific model type.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The name of the simulation model (e.g., \"Wofost72_PP\").</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of available crop names.</p> Source code in <code>cropengine/crop.py</code> <pre><code>def get_available_crops(model: str) -&gt; list[str]:\n    \"\"\"\n    Retrieves a list of supported crops for a specific model type.\n\n    Args:\n        model (str): The name of the simulation model (e.g., \"Wofost72_PP\").\n\n    Returns:\n        list[str]: A list of available crop names.\n    \"\"\"\n    if model.startswith(\"Wofost\"):\n        with pkg_resources.files(wofost_crop_params).joinpath(\"crops.yaml\").open(\n            \"r\"\n        ) as f:\n            available_crops = yaml.safe_load(f)[\"available_crops\"]\n\n        return available_crops\n\n    else:\n        return []\n</code></pre>"},{"location":"cropengine/","title":"cropengine module","text":"<p>Main module.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install cropengine, run this command in your terminal:</p> <pre><code>pip install cropengine\n</code></pre> <p>This is the preferred method to install cropengine, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install cropengine from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/geonextgis/cropengine\n</code></pre>"},{"location":"models/","title":"models module","text":"<p>Module to fetch information about models</p>"},{"location":"site/","title":"site module","text":"<p>Module to prepare site data</p>"},{"location":"site/#cropengine.site.SiteParameterError","title":"<code> SiteParameterError            (Exception)         </code>","text":"<p>Custom exception for site parameter validation errors.</p> Source code in <code>cropengine/site.py</code> <pre><code>class SiteParameterError(Exception):\n    \"\"\"Custom exception for site parameter validation errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"site/#cropengine.site.WOFOSTSiteParametersProvider","title":"<code> WOFOSTSiteParametersProvider        </code>","text":"<p>A unified data provider for WOFOST site-specific parameters.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>The name of the WOFOST model version to use.</p> required <code>**kwargs</code> <p>Site parameters provided as keyword arguments.</p> <code>{}</code> Source code in <code>cropengine/site.py</code> <pre><code>class WOFOSTSiteParametersProvider:\n    \"\"\"\n    A unified data provider for WOFOST site-specific parameters.\n\n    Args:\n        model (str): The name of the WOFOST model version to use.\n        **kwargs: Site parameters provided as keyword arguments.\n    \"\"\"\n\n    def __init__(self, model, **kwargs):\n        self.model = model\n        self.raw_kwargs = kwargs\n        self.param_metadata = []\n        self.required_params = set()\n        self.valid_param_names = set()\n\n        # 1. Load configuration\n        try:\n            with pkg_resources.files(configs).joinpath(\"site_params.yaml\").open(\n                \"r\"\n            ) as f:\n                self.full_config = yaml.safe_load(f)\n        except Exception as e:\n            raise RuntimeError(f\"Failed to load site_params.yaml: {e}\")\n\n        config = self.full_config[\"wofost\"]\n\n        # 2. Validate Model and Prepare Metadata\n        if self.model in config[\"model_mapping\"]:\n\n            profile_name = config[\"model_mapping\"][self.model]\n            profile_def = config[\"profiles\"][profile_name]\n\n            self.valid_param_names = set(profile_def[\"parameters\"])\n            self.required_params = set(profile_def.get(\"required\", []))\n\n            all_param_defs = config[\"site_params\"]\n\n            # Build the Metadata List\n            for param in self.valid_param_names:\n                if param in all_param_defs:\n                    meta = {\n                        \"parameter\": param,\n                        \"required\": (param in self.required_params),\n                    }\n                    meta.update(all_param_defs[param].copy())\n                    self.param_metadata.append(meta)\n        else:\n            pass\n\n    def get_params(self):\n        \"\"\"\n        Validates inputs against the prepared metadata, applies defaults,\n        and returns the final parameter dictionary.\n        \"\"\"\n        # 1. Re-validate Model Profile\n        if not self.param_metadata:\n            valid_models = list(self.full_config[\"wofost\"][\"model_mapping\"].keys())\n            raise SiteParameterError(\n                f\"Unknown or unconfigured model '{self.model}'. Available models: {valid_models}\"\n            )\n\n        validated_params = {}\n\n        # 2. Process Parameters (Iterating over the LIST now)\n        for meta in self.param_metadata:\n            par_name = meta[\"parameter\"]\n\n            # Determine value: use provided kwarg or fall back to default\n            if par_name in self.raw_kwargs:\n                value = self.raw_kwargs[par_name]\n            else:\n                if meta[\"required\"]:\n                    raise SiteParameterError(\n                        f\"Value for parameter '{par_name}' is required for profile '{self.model}'!\"\n                    )\n                value = meta[\"default\"]\n\n            # Convert types and check valid ranges\n            if value is not None:\n                value = self._convert_and_validate(par_name, value, meta)\n\n            validated_params[par_name] = value\n\n        # 3. Check for Unknown Parameters provided by user\n        unknown_keys = [\n            k for k in self.raw_kwargs.keys() if k not in self.valid_param_names\n        ]\n        if unknown_keys:\n            raise SiteParameterError(\n                f\"Unknown parameters provided for profile '{self.model}': {unknown_keys}\"\n            )\n\n        return validated_params\n\n    def _convert_and_validate(self, name, value, definition):\n        \"\"\"\n        Internal helper to cast types and validate ranges.\n        \"\"\"\n        target_type_str = definition[\"type\"]\n\n        # Type Casting\n        try:\n            if target_type_str == \"int\":\n                value = int(value)\n            elif target_type_str == \"float\":\n                value = float(value)\n            elif target_type_str == \"list\":\n                if not isinstance(value, list):\n                    if isinstance(value, str) and \",\" in value:\n                        value = [float(x.strip()) for x in value.split(\",\")]\n                    else:\n                        raise ValueError\n        except (ValueError, TypeError):\n            raise SiteParameterError(\n                f\"Parameter '{name}' must be of type {target_type_str}, got {type(value)}\"\n            )\n\n        # Range Checking\n        valid_range = definition[\"range\"]\n\n        if target_type_str == \"list\":\n            min_val, max_val = valid_range\n            if not all(min_val &lt;= x &lt;= max_val for x in value):\n                raise SiteParameterError(\n                    f\"Elements in list '{name}' must be between {min_val} and {max_val}\"\n                )\n\n        elif target_type_str == \"int\" and valid_range == [0, 1]:\n            if value not in [0, 1]:\n                raise SiteParameterError(f\"Parameter '{name}' must be 0 or 1.\")\n\n        else:\n            min_val, max_val = valid_range\n            if not (min_val &lt;= value &lt;= max_val):\n                raise SiteParameterError(\n                    f\"Value {value} for parameter '{name}' out of range [{min_val}, {max_val}]\"\n                )\n\n        return value\n</code></pre>"},{"location":"site/#cropengine.site.WOFOSTSiteParametersProvider.get_params","title":"<code>get_params(self)</code>","text":"<p>Validates inputs against the prepared metadata, applies defaults, and returns the final parameter dictionary.</p> Source code in <code>cropengine/site.py</code> <pre><code>def get_params(self):\n    \"\"\"\n    Validates inputs against the prepared metadata, applies defaults,\n    and returns the final parameter dictionary.\n    \"\"\"\n    # 1. Re-validate Model Profile\n    if not self.param_metadata:\n        valid_models = list(self.full_config[\"wofost\"][\"model_mapping\"].keys())\n        raise SiteParameterError(\n            f\"Unknown or unconfigured model '{self.model}'. Available models: {valid_models}\"\n        )\n\n    validated_params = {}\n\n    # 2. Process Parameters (Iterating over the LIST now)\n    for meta in self.param_metadata:\n        par_name = meta[\"parameter\"]\n\n        # Determine value: use provided kwarg or fall back to default\n        if par_name in self.raw_kwargs:\n            value = self.raw_kwargs[par_name]\n        else:\n            if meta[\"required\"]:\n                raise SiteParameterError(\n                    f\"Value for parameter '{par_name}' is required for profile '{self.model}'!\"\n                )\n            value = meta[\"default\"]\n\n        # Convert types and check valid ranges\n        if value is not None:\n            value = self._convert_and_validate(par_name, value, meta)\n\n        validated_params[par_name] = value\n\n    # 3. Check for Unknown Parameters provided by user\n    unknown_keys = [\n        k for k in self.raw_kwargs.keys() if k not in self.valid_param_names\n    ]\n    if unknown_keys:\n        raise SiteParameterError(\n            f\"Unknown parameters provided for profile '{self.model}': {unknown_keys}\"\n        )\n\n    return validated_params\n</code></pre>"},{"location":"soil/","title":"soil module","text":"<p>Module to prepare soil data</p>"},{"location":"soil/#cropengine.soil.IsricSoilDataProvider","title":"<code> IsricSoilDataProvider        </code>","text":"<p>Initialize the ISRIC Soil Data Provider.</p> <p>Parameters:</p> Name Type Description Default <code>latitude</code> <code>float</code> <p>The latitude of the location.</p> required <code>longitude</code> <code>float</code> <p>The longitude of the location.</p> required <code>properties</code> <code>list</code> <p>List of soil properties to fetch (e.g., ['clay', 'sand']).                              Defaults to all available in config.</p> <code>None</code> <code>depths</code> <code>list</code> <p>List of depth ranges (e.g., ['0-5cm']).                          Defaults to all available in config.</p> <code>None</code> <code>values</code> <code>list</code> <p>List of statistical values (e.g., ['mean', 'Q0.5']).                          Defaults to all available in config.</p> <code>None</code> <code>filepath</code> <code>str</code> <p>Path to save the resulting CSV file. Defaults to None.</p> <code>None</code> Source code in <code>cropengine/soil.py</code> <pre><code>class IsricSoilDataProvider:\n    \"\"\"\n    Initialize the ISRIC Soil Data Provider.\n\n    Args:\n        latitude (float): The latitude of the location.\n        longitude (float): The longitude of the location.\n        properties (list, optional): List of soil properties to fetch (e.g., ['clay', 'sand']).\n                                         Defaults to all available in config.\n        depths (list, optional): List of depth ranges (e.g., ['0-5cm']).\n                                     Defaults to all available in config.\n        values (list, optional): List of statistical values (e.g., ['mean', 'Q0.5']).\n                                     Defaults to all available in config.\n        filepath (str, optional): Path to save the resulting CSV file. Defaults to None.\n    \"\"\"\n\n    def __init__(\n        self,\n        latitude,\n        longitude,\n        properties=None,\n        depths=None,\n        values=None,\n        filepath=None,\n    ):\n        self.latitude = latitude\n        self.longitude = longitude\n        self.filepath = filepath\n\n        # Internal cache storage\n        self._cached_df = None\n\n        # Load configuration using pkg_resources\n        with pkg_resources.files(configs).joinpath(\"soil.yaml\").open(\"r\") as f:\n            full_config = yaml.safe_load(f)\n\n        self.config = full_config[\"isric_rest_api\"]\n        self.base_url = self.config[\"api\"][\"base_url\"]\n\n        # Validate inputs\n        self.properties = self._validate_input(\n            properties, self.config[\"options\"][\"properties\"], \"Property\"\n        )\n        self.depths = self._validate_input(\n            depths, self.config[\"options\"][\"depths\"], \"Depth\"\n        )\n        self.values = self._validate_input(\n            values, self.config[\"options\"][\"values\"], \"Value\"\n        )\n\n        self.query = {\n            \"lat\": latitude,\n            \"lon\": longitude,\n            \"property\": self.properties,\n            \"depth\": self.depths,\n            \"value\": self.values,\n        }\n\n    def _validate_input(self, user_input, valid_options, category_name):\n        \"\"\"Validates user input against the loaded config options.\"\"\"\n        if user_input is None:\n            return valid_options\n\n        if isinstance(user_input, str):\n            user_input = [user_input]\n\n        # Check for invalid items\n        invalid_items = [item for item in user_input if item not in valid_options]\n\n        if invalid_items:\n            error_msg = (\n                f\"\\nError: Invalid {category_name}(s) provided: {invalid_items}\\n\"\n                f\"Available options in {category_name} are: {valid_options}\"\n            )\n            raise ValueError(error_msg)\n\n        return user_input\n\n    def _extract_data(self):\n        \"\"\"Internal method to hit the API.\"\"\"\n        print(f\"Fetching soil data for {self.latitude}, {self.longitude}...\")\n        try:\n            response = requests.get(self.base_url, params=self.query)\n            response.raise_for_status()\n            print(response)\n            return response.json()\n        except Exception as e:\n            print(f\"Error fetching data: {e}\")\n            return None\n\n    def get_data(self):\n        \"\"\"\n        Fetches, parses, and returns soil data.\n        Uses cached memory if data has already been fetched for this instance.\n        \"\"\"\n        # 1. Check Cache (Optimization)\n        if self._cached_df is not None:\n            print(\"Returning cached data (no API call made).\")\n            return self._cached_df\n\n        # 2. Fetch Data\n        raw_data = self._extract_data()\n\n        if not raw_data:\n            return pd.DataFrame()\n\n        rows = []\n        layers = raw_data.get(\"properties\", {}).get(\"layers\", [])\n\n        # 3. Parse Data\n        for layer in layers:\n            prop_name = layer.get(\"name\")\n\n            # Get Unit Transformation details\n            unit_info = layer.get(\"unit_measure\", {})\n            d_factor = unit_info.get(\"d_factor\", 1)\n\n            # Grab both unit labels\n            mapped_unit = unit_info.get(\"mapped_units\", \"unknown\")  # e.g. \"cg/cm\u00b3\"\n            target_unit = unit_info.get(\"target_units\", \"unknown\")  # e.g. \"kg/dm\u00b3\"\n\n            for depth_record in layer.get(\"depths\", []):\n                depth_range = depth_record.get(\"label\")\n                values_dict = depth_record.get(\"values\", {})\n\n                for metric, raw_val in values_dict.items():\n                    # Calculate transformed value\n                    if isinstance(raw_val, (int, float)) and d_factor != 0:\n                        converted_val = raw_val / d_factor\n                    else:\n                        converted_val = raw_val\n\n                    rows.append(\n                        {\n                            \"latitude\": self.latitude,\n                            \"longitude\": self.longitude,\n                            \"property\": prop_name,\n                            \"depth\": depth_range,\n                            \"metric\": metric,\n                            \"value\": raw_val,\n                            \"unit\": mapped_unit,\n                            \"transformed_value\": converted_val,\n                            \"transformed_unit\": target_unit,\n                        }\n                    )\n\n        df = pd.DataFrame(rows)\n\n        # 4. Update Cache\n        self._cached_df = df\n\n        # 5. Save to File (if requested)\n        if self.filepath and not df.empty:\n            try:\n                df.to_csv(self.filepath, index=False)\n                print(f\"File saved successfully to {self.filepath}\")\n            except Exception as e:\n                print(f\"Failed to save file: {e}\")\n\n        return df\n</code></pre>"},{"location":"soil/#cropengine.soil.IsricSoilDataProvider.get_data","title":"<code>get_data(self)</code>","text":"<p>Fetches, parses, and returns soil data. Uses cached memory if data has already been fetched for this instance.</p> Source code in <code>cropengine/soil.py</code> <pre><code>def get_data(self):\n    \"\"\"\n    Fetches, parses, and returns soil data.\n    Uses cached memory if data has already been fetched for this instance.\n    \"\"\"\n    # 1. Check Cache (Optimization)\n    if self._cached_df is not None:\n        print(\"Returning cached data (no API call made).\")\n        return self._cached_df\n\n    # 2. Fetch Data\n    raw_data = self._extract_data()\n\n    if not raw_data:\n        return pd.DataFrame()\n\n    rows = []\n    layers = raw_data.get(\"properties\", {}).get(\"layers\", [])\n\n    # 3. Parse Data\n    for layer in layers:\n        prop_name = layer.get(\"name\")\n\n        # Get Unit Transformation details\n        unit_info = layer.get(\"unit_measure\", {})\n        d_factor = unit_info.get(\"d_factor\", 1)\n\n        # Grab both unit labels\n        mapped_unit = unit_info.get(\"mapped_units\", \"unknown\")  # e.g. \"cg/cm\u00b3\"\n        target_unit = unit_info.get(\"target_units\", \"unknown\")  # e.g. \"kg/dm\u00b3\"\n\n        for depth_record in layer.get(\"depths\", []):\n            depth_range = depth_record.get(\"label\")\n            values_dict = depth_record.get(\"values\", {})\n\n            for metric, raw_val in values_dict.items():\n                # Calculate transformed value\n                if isinstance(raw_val, (int, float)) and d_factor != 0:\n                    converted_val = raw_val / d_factor\n                else:\n                    converted_val = raw_val\n\n                rows.append(\n                    {\n                        \"latitude\": self.latitude,\n                        \"longitude\": self.longitude,\n                        \"property\": prop_name,\n                        \"depth\": depth_range,\n                        \"metric\": metric,\n                        \"value\": raw_val,\n                        \"unit\": mapped_unit,\n                        \"transformed_value\": converted_val,\n                        \"transformed_unit\": target_unit,\n                    }\n                )\n\n    df = pd.DataFrame(rows)\n\n    # 4. Update Cache\n    self._cached_df = df\n\n    # 5. Save to File (if requested)\n    if self.filepath and not df.empty:\n        try:\n            df.to_csv(self.filepath, index=False)\n            print(f\"File saved successfully to {self.filepath}\")\n        except Exception as e:\n            print(f\"Failed to save file: {e}\")\n\n    return df\n</code></pre>"},{"location":"soil/#cropengine.soil.WOFOSTSoilParameterProvider","title":"<code> WOFOSTSoilParameterProvider        </code>","text":"<p>Calculates soil physics and chemical parameters required for WOFOST crop modeling using ISRIC SoilGrids data.</p> <p>This class extracts soil properties, estimates hydraulic conductivity using Pedotransfer Functions (Cosby), and fits the Van Genuchten equation.</p> <p>Parameters:</p> Name Type Description Default <code>soil_data</code> <code>pd.DataFrame</code> <p>DataFrame containing ISRIC SoilGrids data.</p> required <code>**kwargs</code> <p>Optional overrides for specific soil parameters.</p> <code>{}</code> Source code in <code>cropengine/soil.py</code> <pre><code>class WOFOSTSoilParameterProvider:\n    \"\"\"\n    Calculates soil physics and chemical parameters required for WOFOST\n    crop modeling using ISRIC SoilGrids data.\n\n    This class extracts soil properties, estimates hydraulic conductivity\n    using Pedotransfer Functions (Cosby), and fits the Van Genuchten\n    equation.\n\n    Args:\n        soil_data (pd.DataFrame): DataFrame containing ISRIC SoilGrids data.\n        **kwargs: Optional overrides for specific soil parameters.\n    \"\"\"\n\n    # Default parameters for potential production\n    _defaults = {\n        \"SMFCF\": 0.3,\n        \"SM0\": 0.4,\n        \"SMW\": 0.1,\n        \"RDMSOL\": 120,\n        \"CRAIRC\": 0.06,\n        \"K0\": 10.0,\n        \"SOPE\": 10.0,\n        \"KSUB\": 10.0,\n    }\n\n    def __init__(self, soil_data, **kwargs):\n\n        self.df = soil_data\n        self.params = {}\n\n        # 1. Load Valid Keys dynamically from YAML\n        self.param_metadata = get_wofost_soil_parameters_metadata()\n        self.valid_keys = set(self.param_metadata.keys())\n\n        # 2. Validate kwargs immediately\n        unknown_keys = [k for k in kwargs.keys() if k not in self.valid_keys]\n        if unknown_keys:\n            raise ValueError(\n                f\"Invalid WOFOST parameters provided: {unknown_keys}. \"\n                \"These keys are not defined in the soil configuration.\"\n            )\n\n        self.overrides = kwargs\n\n        # Specific pF points required by WOFOST/PCSE implementations\n        self.pf_range = np.array(\n            [-1.000, 1.000, 1.300, 1.491, 2.000, 2.400, 2.700, 3.400, 4.204, 6.000]\n        )\n        self.h_range = 10**self.pf_range\n\n    def _get_val(self, prop_name):\n        \"\"\"Helper to safely extract a specific property value from the DataFrame.\"\"\"\n        try:\n            return self.df.loc[self.df[\"property\"] == prop_name, \"value\"].values[0]\n        except IndexError:\n            raise ValueError(f\"Missing required property: {prop_name}\")\n\n    def _calculate_ksat_ptf(self, sand_pct, clay_pct):\n        \"\"\"Estimate Ksat (cm/day) using Cosby (1984) PTF.\"\"\"\n        log_ksat = -0.6 + (0.0126 * sand_pct) - (0.0064 * clay_pct)\n        return max(0.1, min((10**log_ksat) * 24, 500.0))\n\n    def _van_genuchten_theta(self, h, theta_r, alpha, n, theta_s):\n        \"\"\"Mualem-Van Genuchten equation.\"\"\"\n        h = np.maximum(h, 0.0)\n        m = 1 - (1 / n)\n        return theta_r + (theta_s - theta_r) / ((1 + (alpha * h) ** n) ** m)\n\n    def _update_param_metadata(self, calc_params):\n        \"\"\"\n        Update the soil parameters metadata.\n        \"\"\"\n        param_metadata = []\n        for param, info in self.param_metadata.items():\n            param_dict = {\"parameter\": param}\n            param_dict.update(info)\n            if param in calc_params.keys():\n                param_dict[\"value\"] = calc_params[param]\n            else:\n                param_dict[\"value\"] = None\n\n            param_metadata.append(param_dict)\n\n        return param_metadata\n\n    def get_params(self):\n        \"\"\"\n        Calculates parameters, fits curves, applies overrides, and returns dictionary.\n        \"\"\"\n        # 1. Extract and Convert Data\n        bdod = self._get_val(\"bdod\") / 100.0\n        soc_g_kg = self._get_val(\"soc\") / 10.0\n        n_g_kg = self._get_val(\"nitrogen\") / 100.0\n        ph = self._get_val(\"phh2o\") / 10.0\n        sand_pct = self._get_val(\"sand\") / 10.0\n        clay_pct = self._get_val(\"clay\") / 10.0\n\n        theta_10 = self._get_val(\"wv0010\") / 1000.0\n        theta_33 = self._get_val(\"wv0033\") / 1000.0\n        theta_1500 = self._get_val(\"wv1500\") / 1000.0\n\n        porosity = 1 - (bdod / 2.65)\n        ksat_est = self._calculate_ksat_ptf(sand_pct, clay_pct)\n\n        # 2. Fit Retention Curve\n        h_obs = np.array([0.01, 100.0, 330.0, 15000.0])\n        theta_obs = np.array([porosity, theta_10, theta_33, theta_1500])\n        p0 = [0.01, 0.01, 1.5]\n        bounds = ([0.0, 1e-5, 1.01], [theta_1500, 10.0, 10.0])\n\n        try:\n            popt, _ = curve_fit(\n                lambda h, tr, a, n: self._van_genuchten_theta(\n                    h, tr, a, n, theta_s=porosity\n                ),\n                h_obs,\n                theta_obs,\n                p0=p0,\n                bounds=bounds,\n                method=\"trf\",\n            )\n            theta_r_opt, alpha_opt, n_opt = popt\n        except Exception as e:\n            print(f\"Scipy fitting failed: {e}. Using default texture-based parameters.\")\n            theta_r_opt, alpha_opt, n_opt = 0.01, 0.01, 1.5\n\n        # 3. Create Pedon Model\n        vg_model = pe.soilmodel.Genuchten(\n            k_s=ksat_est,\n            theta_s=porosity,\n            theta_r=theta_r_opt,\n            alpha=alpha_opt,\n            n=n_opt,\n            l=0.5,\n        )\n\n        # 4. Generate Tables &amp; Scalars\n        theta_curve = vg_model.theta(self.h_range)\n        k_curve = vg_model.k(self.h_range)\n\n        sm_table = []\n        cond_table = []\n        for pf, th, k in zip(self.pf_range, theta_curve, k_curve):\n            sm_table.extend([float(pf), float(th)])\n            k_safe = max(k, 1e-15)\n            cond_table.extend([float(pf), float(np.log10(k_safe))])\n\n        sm0 = vg_model.theta(0.01)\n        smfcf = vg_model.theta(100.0)\n        smw = vg_model.theta(16000.0)\n        crairc = max(0.05, sm0 - smfcf)\n\n        # 5. Chemical Props &amp; Dimensions\n        fsomi = (soc_g_kg * 1.724) / 1000.0\n        cn_ratio = soc_g_kg / n_g_kg if n_g_kg &gt; 0 else 10.0\n\n        depth_str = self.df.iloc[0][\"depth\"]\n        try:\n            top, bottom = depth_str.replace(\"cm\", \"\").split(\"-\")\n            thickness = float(bottom) - float(top)\n        except:\n            thickness = 10.0\n\n        # 6. Construct Final Dictionary\n        self.params = self._defaults.copy()\n\n        # Overwrite with calculated values\n        self.params.update(\n            {\n                \"Soil_pH\": float(round(ph, 3)),\n                \"RHOD\": float(round(bdod, 3)),\n                \"FSOMI\": float(round(fsomi, 3)),\n                \"CNRatioSOMI\": float(round(cn_ratio, 3)),\n                \"Thickness\": float(round(thickness, 3)),\n                \"SM0\": float(round(float(sm0), 3)),\n                \"SMFCF\": float(round(float(smfcf), 3)),\n                \"SMW\": float(round(float(smw), 3)),\n                \"CRAIRC\": float(round(float(crairc), 3)),\n                \"SMfromPF\": [round(x, 3) for x in sm_table],\n                \"CONDfromPF\": [round(x, 3) for x in cond_table],\n            }\n        )\n\n        # 7. Apply Validated Overrides\n        if self.overrides:\n            self.params.update(self.overrides)\n\n        # Update the parameters metadata\n        self.param_metadata = self._update_param_metadata(self.params)\n\n        return self.params\n</code></pre>"},{"location":"soil/#cropengine.soil.WOFOSTSoilParameterProvider.get_params","title":"<code>get_params(self)</code>","text":"<p>Calculates parameters, fits curves, applies overrides, and returns dictionary.</p> Source code in <code>cropengine/soil.py</code> <pre><code>def get_params(self):\n    \"\"\"\n    Calculates parameters, fits curves, applies overrides, and returns dictionary.\n    \"\"\"\n    # 1. Extract and Convert Data\n    bdod = self._get_val(\"bdod\") / 100.0\n    soc_g_kg = self._get_val(\"soc\") / 10.0\n    n_g_kg = self._get_val(\"nitrogen\") / 100.0\n    ph = self._get_val(\"phh2o\") / 10.0\n    sand_pct = self._get_val(\"sand\") / 10.0\n    clay_pct = self._get_val(\"clay\") / 10.0\n\n    theta_10 = self._get_val(\"wv0010\") / 1000.0\n    theta_33 = self._get_val(\"wv0033\") / 1000.0\n    theta_1500 = self._get_val(\"wv1500\") / 1000.0\n\n    porosity = 1 - (bdod / 2.65)\n    ksat_est = self._calculate_ksat_ptf(sand_pct, clay_pct)\n\n    # 2. Fit Retention Curve\n    h_obs = np.array([0.01, 100.0, 330.0, 15000.0])\n    theta_obs = np.array([porosity, theta_10, theta_33, theta_1500])\n    p0 = [0.01, 0.01, 1.5]\n    bounds = ([0.0, 1e-5, 1.01], [theta_1500, 10.0, 10.0])\n\n    try:\n        popt, _ = curve_fit(\n            lambda h, tr, a, n: self._van_genuchten_theta(\n                h, tr, a, n, theta_s=porosity\n            ),\n            h_obs,\n            theta_obs,\n            p0=p0,\n            bounds=bounds,\n            method=\"trf\",\n        )\n        theta_r_opt, alpha_opt, n_opt = popt\n    except Exception as e:\n        print(f\"Scipy fitting failed: {e}. Using default texture-based parameters.\")\n        theta_r_opt, alpha_opt, n_opt = 0.01, 0.01, 1.5\n\n    # 3. Create Pedon Model\n    vg_model = pe.soilmodel.Genuchten(\n        k_s=ksat_est,\n        theta_s=porosity,\n        theta_r=theta_r_opt,\n        alpha=alpha_opt,\n        n=n_opt,\n        l=0.5,\n    )\n\n    # 4. Generate Tables &amp; Scalars\n    theta_curve = vg_model.theta(self.h_range)\n    k_curve = vg_model.k(self.h_range)\n\n    sm_table = []\n    cond_table = []\n    for pf, th, k in zip(self.pf_range, theta_curve, k_curve):\n        sm_table.extend([float(pf), float(th)])\n        k_safe = max(k, 1e-15)\n        cond_table.extend([float(pf), float(np.log10(k_safe))])\n\n    sm0 = vg_model.theta(0.01)\n    smfcf = vg_model.theta(100.0)\n    smw = vg_model.theta(16000.0)\n    crairc = max(0.05, sm0 - smfcf)\n\n    # 5. Chemical Props &amp; Dimensions\n    fsomi = (soc_g_kg * 1.724) / 1000.0\n    cn_ratio = soc_g_kg / n_g_kg if n_g_kg &gt; 0 else 10.0\n\n    depth_str = self.df.iloc[0][\"depth\"]\n    try:\n        top, bottom = depth_str.replace(\"cm\", \"\").split(\"-\")\n        thickness = float(bottom) - float(top)\n    except:\n        thickness = 10.0\n\n    # 6. Construct Final Dictionary\n    self.params = self._defaults.copy()\n\n    # Overwrite with calculated values\n    self.params.update(\n        {\n            \"Soil_pH\": float(round(ph, 3)),\n            \"RHOD\": float(round(bdod, 3)),\n            \"FSOMI\": float(round(fsomi, 3)),\n            \"CNRatioSOMI\": float(round(cn_ratio, 3)),\n            \"Thickness\": float(round(thickness, 3)),\n            \"SM0\": float(round(float(sm0), 3)),\n            \"SMFCF\": float(round(float(smfcf), 3)),\n            \"SMW\": float(round(float(smw), 3)),\n            \"CRAIRC\": float(round(float(crairc), 3)),\n            \"SMfromPF\": [round(x, 3) for x in sm_table],\n            \"CONDfromPF\": [round(x, 3) for x in cond_table],\n        }\n    )\n\n    # 7. Apply Validated Overrides\n    if self.overrides:\n        self.params.update(self.overrides)\n\n    # Update the parameters metadata\n    self.param_metadata = self._update_param_metadata(self.params)\n\n    return self.params\n</code></pre>"},{"location":"soil/#cropengine.soil.get_wofost_soil_parameters_metadata","title":"<code>get_wofost_soil_parameters_metadata()</code>","text":"<p>Parses 'configs/soil_params.yaml' to extract soil parameter definitions.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of parameters with 'description' and 'unit'.</p> Source code in <code>cropengine/soil.py</code> <pre><code>def get_wofost_soil_parameters_metadata():\n    \"\"\"\n    Parses 'configs/soil_params.yaml' to extract soil parameter definitions.\n\n    Returns:\n        dict: Dictionary of parameters with 'description' and 'unit'.\n    \"\"\"\n    metadata = {}\n\n    try:\n        with pkg_resources.files(configs).joinpath(\"soil_params.yaml\").open(\"r\") as f:\n            full_config = yaml.safe_load(f)\n    except (FileNotFoundError, ModuleNotFoundError) as e:\n        raise ValueError(\n            f\"Could not load 'soil_params.yaml' from 'configs'. Error: {e}\"\n        )\n    except yaml.YAMLError as exc:\n        raise ValueError(f\"Error parsing YAML content: {exc}\")\n\n    # Locate the root soil parameters section\n    soil_section = full_config.get(\"wofost\", {}).get(\"soil_params\", {})\n\n    if not soil_section:\n        if \"WaterbalanceFD\" in full_config or \"WaterBalanceLayered\" in full_config:\n            soil_section = full_config\n        else:\n            return {}\n\n    def _recursive_extract(node):\n        for key, value in node.items():\n            if isinstance(value, dict):\n                if \"description\" in value or \"unit\" in value:\n                    metadata[key] = {\n                        \"description\": value.get(\n                            \"description\", \"No description available\"\n                        ),\n                        \"unit\": value.get(\"unit\", \"-\"),\n                    }\n                else:\n                    _recursive_extract(value)\n\n    _recursive_extract(soil_section)\n\n    # Ensure defaults exist\n    if \"K0\" not in metadata:\n        metadata[\"K0\"] = {\n            \"description\": \"Hydraulic conductivity of saturated soil\",\n            \"unit\": \"cm/day\",\n        }\n    if \"IVINF\" not in metadata:\n        metadata[\"IVINF\"] = {\"description\": \"Infiltration limiter\", \"unit\": \"-\"}\n\n    return metadata\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use cropengine in a project:</p> <pre><code>import cropengine\n</code></pre>"},{"location":"weather/","title":"weather module","text":"<p>Module to prepare weather data</p>"},{"location":"weather/#cropengine.weather.ClimateConfig","title":"<code> ClimateConfig        </code>","text":"<p>Parses and holds configuration for climate variables.</p> Source code in <code>cropengine/weather.py</code> <pre><code>class ClimateConfig:\n    \"\"\"Parses and holds configuration for climate variables.\"\"\"\n\n    def __init__(self, config_dict):\n        self.raw = config_dict\n        self.variables = config_dict[\"variables\"]\n        self.all_bands = []\n        self.var_to_bands = {}\n        self.var_to_units = {}\n        self.var_to_conversion = {}\n        self.derived = set()\n        self._parse_variables()\n\n    def _parse_variables(self):\n        for var_name, info in self.variables.items():\n            self.var_to_units[var_name] = (\n                info.get(\"native_unit\"),\n                info.get(\"target_unit\"),\n            )\n            self.var_to_conversion[var_name] = info.get(\"conversion\")\n            if info.get(\"derived\", False):\n                self.derived.add(var_name)\n\n            bands = []\n            for key, value in info.items():\n                if key.startswith(\"band\") and value is not None:\n                    bands.append(value)\n                    self.all_bands.append(value)\n            self.var_to_bands[var_name] = bands\n\n    def get_all_bands(self):\n        return list(set(self.all_bands))\n\n    def is_derived(self, var_name):\n        return var_name in self.derived\n</code></pre>"},{"location":"weather/#cropengine.weather.GEEWeatherDataProvider","title":"<code> GEEWeatherDataProvider        </code>","text":"<p>Handles data retrieval, processing, and export of weather data from Google Earth Engine in PCSE format.</p> <p>IMPORTANT: This class strictly handles POINT data. If a Geometry/Polygon is provided, it extracts data for the CENTROID of that geometry only.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>Start date (YYYY-MM-DD).</p> required <code>end_date</code> <code>str</code> <p>End date (YYYY-MM-DD).</p> required <code>latitude</code> <code>float</code> <p>Latitude (if geometry not provided).</p> <code>None</code> <code>longitude</code> <code>float</code> <p>Longitude (if geometry not provided).</p> <code>None</code> <code>geometry</code> <code>ee.Geometry</code> <p>Polygon or geometry object. Will be converted to its Centroid.</p> <code>None</code> <code>source</code> <code>str</code> <p>Key in meteo.yaml (e.g., 'era5_land').</p> <code>'era5_land'</code> <code>filepath</code> <code>str</code> <p>Default output path.</p> <code>None</code> <code>ee_project</code> <code>str</code> <p>GCloud project ID for GEE initialization.</p> <code>None</code> <code>**site_kwargs</code> <p>Extra metadata for the Excel header (e.g., Station, Country).</p> <code>{}</code> Source code in <code>cropengine/weather.py</code> <pre><code>class GEEWeatherDataProvider:\n    \"\"\"\n    Handles data retrieval, processing, and export of weather data from Google Earth Engine in PCSE format.\n\n    IMPORTANT: This class strictly handles POINT data. If a Geometry/Polygon is provided,\n    it extracts data for the CENTROID of that geometry only.\n\n    Args:\n        start_date (str): Start date (YYYY-MM-DD).\n        end_date (str): End date (YYYY-MM-DD).\n        latitude (float, optional): Latitude (if geometry not provided).\n        longitude (float, optional): Longitude (if geometry not provided).\n        geometry (ee.Geometry, optional): Polygon or geometry object. Will be converted to its Centroid.\n        source (str): Key in meteo.yaml (e.g., 'era5_land').\n        filepath (str, optional): Default output path.\n        ee_project (str, optional): GCloud project ID for GEE initialization.\n        **site_kwargs: Extra metadata for the Excel header (e.g., Station, Country).\n    \"\"\"\n\n    def __init__(\n        self,\n        start_date,\n        end_date,\n        latitude=None,\n        longitude=None,\n        geometry=None,\n        source=\"era5_land\",\n        filepath=None,\n        ee_project=None,\n        **site_kwargs,\n    ):\n\n        self._check_gee_initialized(ee_project)\n\n        if geometry:\n            if isinstance(geometry, (ee.Feature, ee.FeatureCollection)):\n                region_geom = geometry.geometry()\n            else:\n                region_geom = ee.Geometry(geometry)\n\n            # Calculate Centroid\n            try:\n                centroid_obj = region_geom.centroid(maxError=1)\n                coords = centroid_obj.coordinates().getInfo()\n            except Exception:\n                centroid_obj = region_geom.bounds(maxError=1).centroid(maxError=1)\n                coords = centroid_obj.coordinates().getInfo()\n\n            self.longitude = coords[0]\n            self.latitude = coords[1]\n\n        elif latitude is not None and longitude is not None:\n            self.latitude = latitude\n            self.longitude = longitude\n        else:\n            raise ValueError(\n                \"Must provide either 'geometry' OR 'latitude' and 'longitude'.\"\n            )\n\n        self.region = ee.Geometry.Point([self.longitude, self.latitude])\n\n        self.start_date = start_date\n        self.end_date = end_date\n        self.source = source.lower()\n        self.filepath = filepath\n        self.site_kwargs = site_kwargs\n\n        self._cached_df = None\n        self._cached_elevation = None\n\n        with pkg_resources.files(configs).joinpath(\"meteo.yaml\").open(\"r\") as f:\n            full_config = yaml.safe_load(f)\n\n        if source.lower() not in full_config:\n            raise ValueError(\n                f\"Source '{source}' not found. Available: {list(full_config.keys())}\"\n            )\n\n        self.weather_config = full_config[source.lower()]\n        self.cfg = ClimateConfig(self.weather_config)\n\n    def _check_gee_initialized(self, project=None):\n        \"\"\"\n        Checks if GEE is initialized. If not, attempts to initialize.\n        \"\"\"\n        try:\n            ee.Image(0).getInfo()\n        except Exception:\n            print(\"GEE not initialized. Attempting initialization...\")\n            try:\n                # Try initializing with specific project if provided, else default\n                if project:\n                    ee.Initialize(project=project)\n                else:\n                    ee.Initialize()\n                print(\"GEE Initialized successfully.\")\n            except Exception as e:\n                raise RuntimeError(\n                    f\"Failed to initialize Earth Engine: {e}.\\n\"\n                    \"Please run 'earthengine authenticate' in your terminal first.\"\n                )\n\n    def _get_elevation(self):\n\n        if self._cached_elevation is not None:\n            return self._cached_elevation\n\n        try:\n            geom = self.region\n            dem_source = self.weather_config.get(\n                \"dem_source\", \"projects/sat-io/open-datasets/GLO-30\"\n            )\n\n            elev = (\n                ee.ImageCollection(dem_source)\n                .filterBounds(geom)\n                .first()\n                .sample(geom, scale=30)\n                .first()\n                .get(\"b1\")\n            )\n\n            val = elev.getInfo()\n            self._cached_elevation = round(float(val), 3) if val is not None else 0.0\n            return self._cached_elevation\n\n        except Exception as e:\n            print(f\"Warning: Could not fetch elevation ({e}). Defaulting to 0.\")\n            self._cached_elevation = 0.0\n            return 0.0\n\n    def _extract_data(self):\n        \"\"\"\n        Extraction of weather data.\n        \"\"\"\n        band_names = self.cfg.get_all_bands()\n        scale = self.weather_config.get(\"default_scale\", 5000)\n        collection_id = self.weather_config.get(\"collection\")\n\n        ic = ee.ImageCollection(collection_id)\n\n        return extract_timeseries_to_point(\n            lat=self.latitude,\n            lon=self.longitude,\n            image_collection=ic,\n            start_date=self.start_date,\n            end_date=self.end_date,\n            band_names=band_names,\n            scale=scale,\n        )\n\n    def get_data(self):\n        if self._cached_df is not None:\n            return self._cached_df\n\n        df_raw = self._extract_data()\n        output = pd.DataFrame(index=df_raw.index)\n        output[\"date\"] = df_raw[\"time\"]\n\n        for var, bands in self.cfg.var_to_bands.items():\n            conversion = self.cfg.var_to_conversion.get(var)\n            converter_func = CONVERSION_FUNCS.get(conversion, lambda x: x)\n\n            inputs = [df_raw[b] for b in bands]\n\n            try:\n                output[var] = converter_func(*inputs)\n            except TypeError as e:\n                raise ValueError(\n                    f\"Error calculating {var}: Function '{conversion}' \"\n                    f\"expected different arguments than provided bands {bands}. \"\n                    f\"Details: {e}\"\n                )\n\n        self._cached_df = output.round(3)\n        return self._cached_df\n\n    def save_weather_excel(self, filepath=None, **override_kwargs):\n        target_path = filepath or self.filepath\n        if not target_path:\n            raise ValueError(\"Invalid filepath.\")\n\n        df = self.get_data()\n\n        meta_defaults = {\n            \"Country\": \"Unknown\",\n            \"Station\": \"Unknown\",\n            \"Description\": self.weather_config.get(\"description\"),\n            \"Source\": self.weather_config.get(\"collection\"),\n            \"Contact\": \"Unknown\",\n            \"Missing values\": -999,\n            \"AngstromA\": 0.25,\n            \"AngstromB\": 0.50,\n            \"HasSunshine\": False,\n        }\n\n        meta = {**meta_defaults, **self.site_kwargs, **override_kwargs}\n\n        excel_rows = []\n\n        excel_rows.append([\"Site Characteristics\"])\n        excel_rows.append([\"Country\", meta[\"Country\"]])\n        excel_rows.append([\"Station\", meta[\"Station\"]])\n        excel_rows.append([\"Description\", meta[\"Description\"]])\n        excel_rows.append([\"Source\", meta[\"Source\"]])\n        excel_rows.append([\"Contact\", meta[\"Contact\"]])\n        excel_rows.append([\"Missing values\", meta[\"Missing values\"]])\n\n        excel_rows.append(\n            [\n                \"Longitude\",\n                \"Latitude\",\n                \"Elevation\",\n                \"AngstromA\",\n                \"AngstromB\",\n                \"HasSunshine\",\n            ]\n        )\n        excel_rows.append(\n            [\n                self.longitude,\n                self.latitude,\n                self._get_elevation(),\n                meta[\"AngstromA\"],\n                meta[\"AngstromB\"],\n                str(meta[\"HasSunshine\"]).upper(),\n            ]\n        )\n\n        excel_rows.append([\"Observed data\"])\n\n        var_order = [\"IRRAD\", \"TMIN\", \"TMAX\", \"VAP\", \"WIND\", \"RAIN\", \"SNOWDEPTH\"]\n        present_vars = [v for v in var_order if v in df.columns]\n\n        header_names = [\"DAY\"] + present_vars\n        excel_rows.append(header_names)\n\n        header_units = [\"date\"]\n        for v in present_vars:\n            if v in self.cfg.var_to_units:\n                header_units.append(self.cfg.var_to_units[v][1])\n            else:\n                header_units.append(\"-\")\n        excel_rows.append(header_units)\n\n        df_export = df.copy()\n        df_export = df_export.fillna(meta[\"Missing values\"])\n        df_export = df_export[[\"date\"] + present_vars]\n\n        with pd.ExcelWriter(target_path, engine=\"openpyxl\") as writer:\n            pd.DataFrame(excel_rows).to_excel(\n                writer, sheet_name=\"Sheet1\", index=False, header=False, startrow=0\n            )\n\n            df_export.to_excel(\n                writer,\n                sheet_name=\"Sheet1\",\n                index=False,\n                header=False,\n                startrow=len(excel_rows),\n            )\n\n        print(f\"File saved successfully to {target_path}\")\n</code></pre>"},{"location":"examples/crop/","title":"Crop","text":"In\u00a0[\u00a0]: Copied! <pre>from cropengine.crop import WOFOSTCropParametersProvider\n</pre> from cropengine.crop import WOFOSTCropParametersProvider In\u00a0[\u00a0]: Copied! <pre>crop_params = WOFOSTCropParametersProvider(\n    crop_name=\"wheat\", variety_name=\"Winter_wheat_101\"\n)\n</pre> crop_params = WOFOSTCropParametersProvider(     crop_name=\"wheat\", variety_name=\"Winter_wheat_101\" ) In\u00a0[\u00a0]: Copied! <pre>crop_params.keys()\n</pre> crop_params.keys() In\u00a0[\u00a0]: Copied! <pre>crop_params.\n</pre> crop_params. In\u00a0[\u00a0]: Copied! <pre>from pcse.input import YAMLCropDataProvider\n\nc_d = YAMLCropDataProvider()\n</pre> from pcse.input import YAMLCropDataProvider  c_d = YAMLCropDataProvider() In\u00a0[\u00a0]: Copied! <pre>c_d.get_crops_varieties()\n</pre> c_d.get_crops_varieties() In\u00a0[\u00a0]: Copied! <pre>crop_params.get_crops_varieties()\n</pre> crop_params.get_crops_varieties()"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[\u00a0]: Copied! <pre>print(\"Hello World!\")\n</pre> print(\"Hello World!\")"},{"location":"examples/run/","title":"Run","text":"In\u00a0[\u00a0]: Copied! <pre>import os\nfrom datetime import datetime, date, timedelta\nimport pandas as pd\nimport ee\n</pre> import os from datetime import datetime, date, timedelta import pandas as pd import ee In\u00a0[\u00a0]: Copied! <pre>from cropengine.models import get_available_models\nfrom cropengine.crop import get_available_crops, get_available_crop_varieties\n\n# Location\nlatitude = 52.53\nlongitude = 14.12\n\n# Crop information\ncampaign_start_date = \"2006-01-01\"\ncrop_start_date = \"2006-04-05\"\ncrop_start_type = \"emergence\"\n\ncrop_end_date = \"2006-10-20\"\ncrop_end_type = \"harvest\"\ncampaign_end_date = \"2007-01-01\"\n\nmax_duration = 300\n\n# Other inputs\n# Get the available model info (**To be displayed in the dashboard)\nmodels_info = get_available_models()\nmodel = \"Wofost72_WLP_CWB\"  # User can select from 'models_info' dropdown\n\ncrops_info = get_available_crops(model)\ncrop_name = \"sugarbeet\"  # User can select from 'crops_info' dropdown\n\ncrop_varieties_info = get_available_crop_varieties(\n    model, crop_name\n)  # User can select from 'crop_varieties_info' dropdown\ncrop_variety = \"Sugarbeet_601\"  # User can select from 'crop_varieties_info' dropdown\n</pre> from cropengine.models import get_available_models from cropengine.crop import get_available_crops, get_available_crop_varieties  # Location latitude = 52.53 longitude = 14.12  # Crop information campaign_start_date = \"2006-01-01\" crop_start_date = \"2006-04-05\" crop_start_type = \"emergence\"  crop_end_date = \"2006-10-20\" crop_end_type = \"harvest\" campaign_end_date = \"2007-01-01\"  max_duration = 300  # Other inputs # Get the available model info (**To be displayed in the dashboard) models_info = get_available_models() model = \"Wofost72_WLP_CWB\"  # User can select from 'models_info' dropdown  crops_info = get_available_crops(model) crop_name = \"sugarbeet\"  # User can select from 'crops_info' dropdown  crop_varieties_info = get_available_crop_varieties(     model, crop_name )  # User can select from 'crop_varieties_info' dropdown crop_variety = \"Sugarbeet_601\"  # User can select from 'crop_varieties_info' dropdown In\u00a0[\u00a0]: Copied! <pre>workspace_dir = os.path.join(\".\", \"workspace\")  # To be decided by Jahid\nos.makedirs(workspace_dir, exist_ok=True)\n</pre> workspace_dir = os.path.join(\".\", \"workspace\")  # To be decided by Jahid os.makedirs(workspace_dir, exist_ok=True) In\u00a0[\u00a0]: Copied! <pre>from cropengine.weather import GEEWeatherDataProvider\n\n# ee.Authenticate()\n# Prepare weather data for a specific point\nfrom datetime import datetime, timedelta\n\n\ndef make_inclusive(end_date_str: str) -&gt; str:\n    \"\"\"Convert string to date, add 1 day, return string.\"\"\"\n    d = datetime.strptime(end_date_str, \"%Y-%m-%d\").date()\n    d_inc = d + timedelta(days=1)\n    return d_inc.strftime(\"%Y-%m-%d\")\n\n\ncampaign_end_date_inclusive = make_inclusive(campaign_end_date)\nmeteo_data = GEEWeatherDataProvider(\n    start_date=campaign_start_date,\n    end_date=campaign_end_date_inclusive,\n    latitude=latitude,\n    longitude=longitude,\n    filepath=os.path.join(workspace_dir, \"meteo.xlsx\"),\n)\nmeteo_data.save_weather_excel()\n</pre> from cropengine.weather import GEEWeatherDataProvider  # ee.Authenticate() # Prepare weather data for a specific point from datetime import datetime, timedelta   def make_inclusive(end_date_str: str) -&gt; str:     \"\"\"Convert string to date, add 1 day, return string.\"\"\"     d = datetime.strptime(end_date_str, \"%Y-%m-%d\").date()     d_inc = d + timedelta(days=1)     return d_inc.strftime(\"%Y-%m-%d\")   campaign_end_date_inclusive = make_inclusive(campaign_end_date) meteo_data = GEEWeatherDataProvider(     start_date=campaign_start_date,     end_date=campaign_end_date_inclusive,     latitude=latitude,     longitude=longitude,     filepath=os.path.join(workspace_dir, \"meteo.xlsx\"), ) meteo_data.save_weather_excel() In\u00a0[\u00a0]: Copied! <pre>from cropengine.soil import IsricSoilDataProvider, WOFOSTSoilParameterProvider\n\n# Prepare soil data for a specific point\nsoil_data = IsricSoilDataProvider(\n    latitude=latitude,\n    longitude=longitude,\n    depths=\"0-5cm\",\n    values=[\"mean\"],\n    filepath=os.path.join(workspace_dir, \"soil.csv\"),\n)\n# soil_data = soil_data.get_data()\nsoil_data = pd.read_csv(\n    \"/beegfs/halder/GITHUB/LEARNING/cropengine/docs/examples/workspace/soil.csv\"\n)\nsoil_data = soil_data[soil_data[\"metric\"] == \"mean\"]\n\n# Extract soil parameters from the soil data\nsoil_params_provider = WOFOSTSoilParameterProvider(soil_data)\nsoil_params = soil_params_provider.get_params()\n</pre> from cropengine.soil import IsricSoilDataProvider, WOFOSTSoilParameterProvider  # Prepare soil data for a specific point soil_data = IsricSoilDataProvider(     latitude=latitude,     longitude=longitude,     depths=\"0-5cm\",     values=[\"mean\"],     filepath=os.path.join(workspace_dir, \"soil.csv\"), ) # soil_data = soil_data.get_data() soil_data = pd.read_csv(     \"/beegfs/halder/GITHUB/LEARNING/cropengine/docs/examples/workspace/soil.csv\" ) soil_data = soil_data[soil_data[\"metric\"] == \"mean\"]  # Extract soil parameters from the soil data soil_params_provider = WOFOSTSoilParameterProvider(soil_data) soil_params = soil_params_provider.get_params() In\u00a0[\u00a0]: Copied! <pre>soil_params_info = (\n    soil_params_provider.param_metadata\n)  # User can change parameters' value from 'soil_params_info' table\nsoil_params_info = (\n    pd.DataFrame(soil_params_info).sort_values(by=\"parameter\").reset_index(drop=True)\n)\nprint(soil_params_info.shape)\nsoil_params_info\n</pre> soil_params_info = (     soil_params_provider.param_metadata )  # User can change parameters' value from 'soil_params_info' table soil_params_info = (     pd.DataFrame(soil_params_info).sort_values(by=\"parameter\").reset_index(drop=True) ) print(soil_params_info.shape) soil_params_info In\u00a0[\u00a0]: Copied! <pre>from cropengine.site import WOFOSTSiteParametersProvider\n\n# Extract site parameters\nsite_params_provider = WOFOSTSiteParametersProvider(model, WAV=10)\nsite_params = site_params_provider.get_params()\n</pre> from cropengine.site import WOFOSTSiteParametersProvider  # Extract site parameters site_params_provider = WOFOSTSiteParametersProvider(model, WAV=10) site_params = site_params_provider.get_params() In\u00a0[\u00a0]: Copied! <pre>site_params_info = (\n    site_params_provider.param_metadata\n)  # User can change parameters' value from 'site_params_info' table\nsite_params_info = (\n    pd.DataFrame(site_params_info).sort_values(by=\"parameter\").reset_index(drop=True)\n)\nprint(site_params_info.shape)\nsite_params_info\n</pre> site_params_info = (     site_params_provider.param_metadata )  # User can change parameters' value from 'site_params_info' table site_params_info = (     pd.DataFrame(site_params_info).sort_values(by=\"parameter\").reset_index(drop=True) ) print(site_params_info.shape) site_params_info In\u00a0[\u00a0]: Copied! <pre>from cropengine.crop import WOFOSTCropParametersProvider\n\n# Extract crop parameters\ncrop_params_provider = WOFOSTCropParametersProvider(\n    crop_name=crop_name, variety_name=crop_variety\n)\nprint(crop_params_provider)\n</pre> from cropengine.crop import WOFOSTCropParametersProvider  # Extract crop parameters crop_params_provider = WOFOSTCropParametersProvider(     crop_name=crop_name, variety_name=crop_variety ) print(crop_params_provider) In\u00a0[\u00a0]: Copied! <pre>crop_params_info = (\n    crop_params_provider.param_metadata\n)  # User can change parameters' value from 'crop_params_info' table\ncrop_params_info = (\n    pd.DataFrame(crop_params_info).sort_values(by=\"parameter\").reset_index(drop=True)\n)\nprint(crop_params_info.shape)\ncrop_params_info\n</pre> crop_params_info = (     crop_params_provider.param_metadata )  # User can change parameters' value from 'crop_params_info' table crop_params_info = (     pd.DataFrame(crop_params_info).sort_values(by=\"parameter\").reset_index(drop=True) ) print(crop_params_info.shape) crop_params_info In\u00a0[\u00a0]: Copied! <pre>from pcse.base import ParameterProvider\n\ncrop_dict = dict(zip(crop_params_info[\"parameter\"], crop_params_info[\"default\"]))\nsoil_params_info = soil_params_info.dropna()\nsoil_dict = dict(zip(soil_params_info[\"parameter\"], soil_params_info[\"value\"]))\nsite_dict = site_params.copy()\n\nparameters = ParameterProvider(\n    cropdata=crop_dict, soildata=soil_dict, sitedata=site_dict\n)\n</pre> from pcse.base import ParameterProvider  crop_dict = dict(zip(crop_params_info[\"parameter\"], crop_params_info[\"default\"])) soil_params_info = soil_params_info.dropna() soil_dict = dict(zip(soil_params_info[\"parameter\"], soil_params_info[\"value\"])) site_dict = site_params.copy()  parameters = ParameterProvider(     cropdata=crop_dict, soildata=soil_dict, sitedata=site_dict ) In\u00a0[\u00a0]: Copied! <pre>from cropengine.agromanagement import WOFOSTAgroEventBuilder\n\nagro_event_builder = WOFOSTAgroEventBuilder()\n\n# Build timed events (irrigation)\nirrigation_schedule = [\n    {\"event_date\": \"2006-05-25\", \"amount\": 3.0, \"efficiency\": 0.7},\n    {\"event_date\": \"2006-06-30\", \"amount\": 2.5, \"efficiency\": 0.7},\n]\n\nirrigation_events = agro_event_builder.create_timed_events(\n    signal_type=\"irrigate\", events_list=irrigation_schedule\n)\n\n# Build state Events (fertilization based on DVS)\nnitrogen_schedule = [\n    {\"threshold\": 0.3, \"N_amount\": 40, \"N_recovery\": 0.7},\n    {\"threshold\": 0.6, \"N_amount\": 60, \"N_recovery\": 0.7},\n    {\"threshold\": 1.12, \"N_amount\": 40, \"N_recovery\": 0.7},\n]\n\nnitrogen_events = agro_event_builder.create_state_events(\n    signal_type=\"apply_n\",\n    state_var=\"DVS\",\n    zero_condition=\"rising\",\n    events_list=nitrogen_schedule,\n)\n</pre> from cropengine.agromanagement import WOFOSTAgroEventBuilder  agro_event_builder = WOFOSTAgroEventBuilder()  # Build timed events (irrigation) irrigation_schedule = [     {\"event_date\": \"2006-05-25\", \"amount\": 3.0, \"efficiency\": 0.7},     {\"event_date\": \"2006-06-30\", \"amount\": 2.5, \"efficiency\": 0.7}, ]  irrigation_events = agro_event_builder.create_timed_events(     signal_type=\"irrigate\", events_list=irrigation_schedule )  # Build state Events (fertilization based on DVS) nitrogen_schedule = [     {\"threshold\": 0.3, \"N_amount\": 40, \"N_recovery\": 0.7},     {\"threshold\": 0.6, \"N_amount\": 60, \"N_recovery\": 0.7},     {\"threshold\": 1.12, \"N_amount\": 40, \"N_recovery\": 0.7}, ]  nitrogen_events = agro_event_builder.create_state_events(     signal_type=\"apply_n\",     state_var=\"DVS\",     zero_condition=\"rising\",     events_list=nitrogen_schedule, ) In\u00a0[\u00a0]: Copied! <pre>from cropengine.agromanagement import WOFOSTAgroManagementProvider\n\nagro_management_provider = WOFOSTAgroManagementProvider()\n\n# Add campaign with events to provider\nagro_management_provider.add_campaign(\n    campaign_start_date=campaign_start_date,\n    campaign_end_date=campaign_end_date,\n    crop_name=crop_name,\n    variety_name=crop_variety,\n    crop_start_date=crop_start_date,\n    crop_end_date=crop_end_date,\n    crop_start_type=crop_start_type,\n    crop_end_type=crop_end_type,\n    max_duration=max_duration,\n    timed_events=[irrigation_events],  # Note: this must be a list of event objects\n    state_events=[nitrogen_events],  # Note: this must be a list of event objects\n)\nagro_management_provider.add_trailing_empty_campaign()\n# Save to YAML\nagro_management_provider.save_to_yaml(os.path.join(workspace_dir, \"agro.yaml\"))\nprint(\"YAML file saved successfully.\")\n</pre> from cropengine.agromanagement import WOFOSTAgroManagementProvider  agro_management_provider = WOFOSTAgroManagementProvider()  # Add campaign with events to provider agro_management_provider.add_campaign(     campaign_start_date=campaign_start_date,     campaign_end_date=campaign_end_date,     crop_name=crop_name,     variety_name=crop_variety,     crop_start_date=crop_start_date,     crop_end_date=crop_end_date,     crop_start_type=crop_start_type,     crop_end_type=crop_end_type,     max_duration=max_duration,     timed_events=[irrigation_events],  # Note: this must be a list of event objects     state_events=[nitrogen_events],  # Note: this must be a list of event objects ) agro_management_provider.add_trailing_empty_campaign() # Save to YAML agro_management_provider.save_to_yaml(os.path.join(workspace_dir, \"agro.yaml\")) print(\"YAML file saved successfully.\") In\u00a0[\u00a0]: Copied! <pre>from pcse.input import YAMLAgroManagementReader\n\nagromanagement = YAMLAgroManagementReader(os.path.join(workspace_dir, \"agro.yaml\"))\nprint(agromanagement)\n</pre> from pcse.input import YAMLAgroManagementReader  agromanagement = YAMLAgroManagementReader(os.path.join(workspace_dir, \"agro.yaml\")) print(agromanagement) In\u00a0[\u00a0]: Copied! <pre>from pcse.input import ExcelWeatherDataProvider\n\nweatherfile = os.path.join(workspace_dir, \"meteo.xlsx\")\nweatherdataprovider = ExcelWeatherDataProvider(weatherfile)\nprint(weatherdataprovider)\n</pre> from pcse.input import ExcelWeatherDataProvider  weatherfile = os.path.join(workspace_dir, \"meteo.xlsx\") weatherdataprovider = ExcelWeatherDataProvider(weatherfile) print(weatherdataprovider) In\u00a0[\u00a0]: Copied! <pre>from pcse.models import Wofost72_WLP_CWB\n\nwofsim = Wofost72_WLP_CWB(parameters, weatherdataprovider, agromanagement)\n</pre> from pcse.models import Wofost72_WLP_CWB  wofsim = Wofost72_WLP_CWB(parameters, weatherdataprovider, agromanagement) In\u00a0[\u00a0]: Copied! <pre>wofsim.run_till_terminate()\ndf_results = pd.DataFrame(wofsim.get_output())\ndf_results = df_results.set_index(\"day\")\ndf_results.tail()\n</pre> wofsim.run_till_terminate() df_results = pd.DataFrame(wofsim.get_output()) df_results = df_results.set_index(\"day\") df_results.tail() In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\nimport seaborn as sns\n\nfig, axes = plt.subplots(nrows=5, ncols=1, figsize=(12, 12), sharex=True)\naxes = axes.flatten()\n\nfor i, var in enumerate([\"DVS\", \"TAGP\", \"LAI\", \"SM\", \"TWSO\"]):\n    sns.lineplot(x=df_results.index, y=df_results[var], ax=axes[i])\n\nplt.tight_layout()\nplt.show()\n</pre> import matplotlib.pyplot as plt import seaborn as sns  fig, axes = plt.subplots(nrows=5, ncols=1, figsize=(12, 12), sharex=True) axes = axes.flatten()  for i, var in enumerate([\"DVS\", \"TAGP\", \"LAI\", \"SM\", \"TWSO\"]):     sns.lineplot(x=df_results.index, y=df_results[var], ax=axes[i])  plt.tight_layout() plt.show()"},{"location":"examples/run/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"examples/run/#user-inputs","title":"User inputs\u00b6","text":""},{"location":"examples/run/#create-workspace-directory","title":"Create workspace directory\u00b6","text":""},{"location":"examples/run/#data-and-parameters-preparation","title":"Data and parameters preparation\u00b6","text":""},{"location":"examples/run/#weather","title":"Weather\u00b6","text":""},{"location":"examples/run/#soil","title":"Soil\u00b6","text":""},{"location":"examples/run/#site","title":"Site\u00b6","text":""},{"location":"examples/run/#crop","title":"Crop\u00b6","text":""},{"location":"examples/run/#packing-all-parameters","title":"Packing all parameters\u00b6","text":""},{"location":"examples/run/#define-agromanagement","title":"Define agromanagement\u00b6","text":""},{"location":"examples/run/#create-irrigation-timed-events","title":"Create irrigation timed events\u00b6","text":""},{"location":"examples/run/#create-agromanagement-with-timed-events","title":"Create agromanagement with timed events\u00b6","text":""},{"location":"examples/run/#load-the-weather-data","title":"Load the weather data\u00b6","text":""},{"location":"examples/run/#run-the-model","title":"Run the model\u00b6","text":""},{"location":"examples/site/","title":"Site","text":"In\u00a0[\u00a0]: Copied! <pre>from cropengine.site import WOFOSTSiteParametersProvider\n</pre> from cropengine.site import WOFOSTSiteParametersProvider In\u00a0[\u00a0]: Copied! <pre>site_param_provider = WOFOSTSiteParametersProvider(\"Wofost72_PP\", **{\"WAV\": 10})\n</pre> site_param_provider = WOFOSTSiteParametersProvider(\"Wofost72_PP\", **{\"WAV\": 10}) In\u00a0[\u00a0]: Copied! <pre>dict(site_param_provider)\n</pre> dict(site_param_provider) In\u00a0[\u00a0]: Copied! <pre>site_param_provider.param_metadata.keys()\n</pre> site_param_provider.param_metadata.keys()"},{"location":"examples/soil/","title":"Soil","text":"In\u00a0[\u00a0]: Copied! <pre>from cropengine.soil import IsricSoilDataProvider, WOFOSTSoilParameterProvider\n</pre> from cropengine.soil import IsricSoilDataProvider, WOFOSTSoilParameterProvider In\u00a0[\u00a0]: Copied! <pre>soil_data_provider = IsricSoilDataProvider(\n    latitude=52.53,\n    longitude=14.12,\n    properties=[\n        \"bdod\",\n        \"cec\",\n        \"cfvo\",\n        \"clay\",\n        \"nitrogen\",\n        \"ocd\",\n        \"ocs\",\n        \"phh2o\",\n        \"sand\",\n        \"silt\",\n        \"soc\",\n        \"wv0010\",\n        \"wv0033\",\n        \"wv1500\",\n    ],\n    depths=[\"0-5cm\"],\n    values=\"mean\",\n)\nsoil_data = soil_data_provider.get_data()\nprint(soil_data.shape)\nsoil_data.head()\n</pre> soil_data_provider = IsricSoilDataProvider(     latitude=52.53,     longitude=14.12,     properties=[         \"bdod\",         \"cec\",         \"cfvo\",         \"clay\",         \"nitrogen\",         \"ocd\",         \"ocs\",         \"phh2o\",         \"sand\",         \"silt\",         \"soc\",         \"wv0010\",         \"wv0033\",         \"wv1500\",     ],     depths=[\"0-5cm\"],     values=\"mean\", ) soil_data = soil_data_provider.get_data() print(soil_data.shape) soil_data.head() In\u00a0[\u00a0]: Copied! <pre># Calculate soil parameters\ncalc = WOFOSTSoilParameterProvider(soil_data, **{\"SSI\": 10})\npcse_soil_params = calc.get_params()\nprint(pcse_soil_params)\n</pre> # Calculate soil parameters calc = WOFOSTSoilParameterProvider(soil_data, **{\"SSI\": 10}) pcse_soil_params = calc.get_params() print(pcse_soil_params) In\u00a0[\u00a0]: Copied! <pre>pcse_soil_params\n</pre> pcse_soil_params In\u00a0[\u00a0]: Copied! <pre>calc.param_metadata\n</pre> calc.param_metadata"},{"location":"examples/weather/","title":"Weather","text":"In\u00a0[\u00a0]: Copied! <pre>from cropengine.weather import GEEWeatherDataProvider\n</pre> from cropengine.weather import GEEWeatherDataProvider In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n\nee.Initialize()\n</pre> import ee import geemap  ee.Initialize() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(basemap=\"SATELLITE\")\nMap\n</pre> Map = geemap.Map(basemap=\"SATELLITE\") Map In\u00a0[\u00a0]: Copied! <pre>region = Map.draw_last_feature\n</pre> region = Map.draw_last_feature In\u00a0[\u00a0]: Copied! <pre># climdata = GEEWeatherDataProvider(latitude=52.06912171608079, longitude=10.881185799808796, start_date='2020-01-01', end_date='2022-12-31', source='era5_land')\nclimdata_region = GEEWeatherDataProvider(\n    geometry=region,\n    reducer=\"mean\",\n    start_date=\"2020-01-01\",\n    end_date=\"2022-12-31\",\n    source=\"era5_land\",\n)\n</pre> # climdata = GEEWeatherDataProvider(latitude=52.06912171608079, longitude=10.881185799808796, start_date='2020-01-01', end_date='2022-12-31', source='era5_land') climdata_region = GEEWeatherDataProvider(     geometry=region,     reducer=\"mean\",     start_date=\"2020-01-01\",     end_date=\"2022-12-31\",     source=\"era5_land\", ) In\u00a0[\u00a0]: Copied! <pre>climdata.get_data()\n</pre> climdata.get_data() In\u00a0[\u00a0]: Copied! <pre># climdata_region.save_weather_excel('data.xlsx')\n</pre> # climdata_region.save_weather_excel('data.xlsx') In\u00a0[\u00a0]: Copied! <pre>import requests\n\n\ndef fetch_soilgrids_data(lat, lon):\n    \"\"\"\n    Fetches specific SoilGrids v2.0 data for WOFOST/PCSE.\n    Mirrors the 'fetchSoilGrids' R function logic.\n    \"\"\"\n\n    # 1. Define the Endpoint\n    base_url = \"https://rest.isric.org/soilgrids/v2.0/properties/query\"\n\n    # 2. Define the Parameters (mapping from your R snippet)\n    # Note: 'wv' variables = Volumetric Water Content (Standard V2.0 properties)\n    params = {\n        \"lat\": lat,\n        \"lon\": lon,\n        \"depth\": [\"0-5cm\", \"5-15cm\", \"15-30cm\", \"30-60cm\", \"60-100cm\"],\n        \"property\": [\n            \"bdod\",  # Bulk Density (cg/cm3)\n            \"clay\",  # Clay (g/kg)\n            \"sand\",  # Sand (g/kg)\n            \"soc\",  # Soil Organic Carbon (dg/kg)\n            \"wv0010\",  # Water Content at 10kPa (Volume %)\n            \"wv0033\",  # Water Content at 33kPa (Volume %) -&gt; Field Capacity\n            \"wv1500\",  # Water Content at 1500kPa (Volume %) -&gt; Wilting Point\n        ],\n        \"value\": \"mean\",  # equivalent to summary_type='mean'\n    }\n\n    # 3. Make the Request\n    print(f\"Fetching data for {lat}, {lon}...\")\n    response = requests.get(base_url, params=params)\n\n    if response.status_code != 200:\n        print(f\"Error: {response.status_code}\")\n        return None\n\n    data = response.json()\n\n    # 4. Parse the complex JSON structure into a simple dictionary\n    # We want to average the top 3 layers (0-30cm) for the crop model\n    target_depths = [\"0-5cm\", \"5-15cm\", \"15-30cm\"]\n    parsed_data = {}\n\n    for layer in data[\"properties\"][\"layers\"]:\n        prop_name = layer[\"name\"]\n\n        # Collect values for the relevant depths\n        values = [\n            d[\"values\"][\"mean\"]\n            for d in layer[\"depths\"]\n            if d[\"label\"] in target_depths and d[\"values\"][\"mean\"] is not None\n        ]\n\n        if values:\n            avg_value = sum(values) / len(values)\n            parsed_data[prop_name] = avg_value\n        else:\n            parsed_data[prop_name] = None\n\n    return parsed_data\n\n\n# --- USAGE ---\n# Example coordinates (Wageningen, NL)\nsoil_data = fetch_soilgrids_data(lat=51.99747, lon=12.16551)\nprint(\"Fetched Data (Raw Units):\")\nprint(soil_data)\n</pre> import requests   def fetch_soilgrids_data(lat, lon):     \"\"\"     Fetches specific SoilGrids v2.0 data for WOFOST/PCSE.     Mirrors the 'fetchSoilGrids' R function logic.     \"\"\"      # 1. Define the Endpoint     base_url = \"https://rest.isric.org/soilgrids/v2.0/properties/query\"      # 2. Define the Parameters (mapping from your R snippet)     # Note: 'wv' variables = Volumetric Water Content (Standard V2.0 properties)     params = {         \"lat\": lat,         \"lon\": lon,         \"depth\": [\"0-5cm\", \"5-15cm\", \"15-30cm\", \"30-60cm\", \"60-100cm\"],         \"property\": [             \"bdod\",  # Bulk Density (cg/cm3)             \"clay\",  # Clay (g/kg)             \"sand\",  # Sand (g/kg)             \"soc\",  # Soil Organic Carbon (dg/kg)             \"wv0010\",  # Water Content at 10kPa (Volume %)             \"wv0033\",  # Water Content at 33kPa (Volume %) -&gt; Field Capacity             \"wv1500\",  # Water Content at 1500kPa (Volume %) -&gt; Wilting Point         ],         \"value\": \"mean\",  # equivalent to summary_type='mean'     }      # 3. Make the Request     print(f\"Fetching data for {lat}, {lon}...\")     response = requests.get(base_url, params=params)      if response.status_code != 200:         print(f\"Error: {response.status_code}\")         return None      data = response.json()      # 4. Parse the complex JSON structure into a simple dictionary     # We want to average the top 3 layers (0-30cm) for the crop model     target_depths = [\"0-5cm\", \"5-15cm\", \"15-30cm\"]     parsed_data = {}      for layer in data[\"properties\"][\"layers\"]:         prop_name = layer[\"name\"]          # Collect values for the relevant depths         values = [             d[\"values\"][\"mean\"]             for d in layer[\"depths\"]             if d[\"label\"] in target_depths and d[\"values\"][\"mean\"] is not None         ]          if values:             avg_value = sum(values) / len(values)             parsed_data[prop_name] = avg_value         else:             parsed_data[prop_name] = None      return parsed_data   # --- USAGE --- # Example coordinates (Wageningen, NL) soil_data = fetch_soilgrids_data(lat=51.99747, lon=12.16551) print(\"Fetched Data (Raw Units):\") print(soil_data) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"}]}