{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to cropengine","text":"<p>cropengine is a Python package that streamlines running process-based crop models by automating data preparation, simulation workflows, and result analysis.</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://geonextgis.github.io/cropengine</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/geonextgis/cropengine/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>cropengine could always use more documentation, whether as part of the official cropengine docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/geonextgis/cropengine/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up cropengine for local development.</p> <ol> <li> <p>Fork the cropengine repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/cropengine.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv cropengine\n$ cd cropengine/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 cropengine tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/geonextgis/cropengine/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"conversions/","title":"conversions module","text":""},{"location":"conversions/#cropengine.conversions.Td_to_VAP","title":"<code>Td_to_VAP(dewpoint_K)</code>","text":"<p>Compute vapour pressure (hPa) from dewpoint temperature (K).</p> Source code in <code>cropengine/conversions.py</code> <pre><code>def Td_to_VAP(dewpoint_K):\n    \"\"\"Compute vapour pressure (hPa) from dewpoint temperature (K).\"\"\"\n    # Handle Series or scalar\n    Td_C = dewpoint_K - 273.15\n    vap_kPa = 0.6108 * np.exp((17.27 * Td_C) / (Td_C + 237.3))\n    return vap_kPa\n</code></pre>"},{"location":"conversions/#cropengine.conversions.uv_to_wind","title":"<code>uv_to_wind(u, v)</code>","text":"<p>Compute wind speed magnitude (m/s).</p> Source code in <code>cropengine/conversions.py</code> <pre><code>def uv_to_wind(u, v):\n    \"\"\"Compute wind speed magnitude (m/s).\"\"\"\n    return np.sqrt(u**2 + v**2)\n</code></pre>"},{"location":"cropengine/","title":"cropengine module","text":"<p>Main module.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install cropengine, run this command in your terminal:</p> <pre><code>pip install cropengine\n</code></pre> <p>This is the preferred method to install cropengine, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install cropengine from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/geonextgis/cropengine\n</code></pre>"},{"location":"site/","title":"site module","text":"<p>Module to prepare site data</p>"},{"location":"site/#cropengine.site.SiteParameterError","title":"<code> SiteParameterError            (Exception)         </code>","text":"<p>Custom exception for site parameter validation errors.</p> Source code in <code>cropengine/site.py</code> <pre><code>class SiteParameterError(Exception):\n    \"\"\"Custom exception for site parameter validation errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"site/#cropengine.site.WOFOSTSiteParametersProvider","title":"<code> WOFOSTSiteParametersProvider            (dict)         </code>","text":"<p>A unified data provider for WOFOST site-specific parameters.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>str</code> <p>The name of the WOFOST model version to use.</p> required <code>**kwargs</code> <p>Site parameters provided as keyword arguments.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>valid_param_names</code> <code>set</code> <p>A set of parameter names allowed for the selected profile.</p> <code>required_params</code> <code>set</code> <p>A set of parameter names that must be provided by the user.</p> <code>param_metadata</code> <code>dict</code> <p>Metadata (range, type, default) for the valid parameters.</p> <p>Exceptions:</p> Type Description <code>SiteParameterError</code> <p>If the profile is unknown, if required parameters                 are missing, or if provided parameters fail validation                 (incorrect type, out of range, or unknown key).</p> Source code in <code>cropengine/site.py</code> <pre><code>class WOFOSTSiteParametersProvider(dict):\n    \"\"\"\n    A unified data provider for WOFOST site-specific parameters.\n\n    Args:\n        profile (str): The name of the WOFOST model version to use.\n        (e.g., 'WOFOST72', 'WOFOST73', 'WOFOST81_SNOMIN').\n        **kwargs: Site parameters provided as keyword arguments.\n        (e.g., WAV=10.0, CO2=400, NH4I=[...]).\n\n    Attributes:\n        valid_param_names (set): A set of parameter names allowed for the selected profile.\n        required_params (set): A set of parameter names that must be provided by the user.\n        param_metadata (dict): Metadata (range, type, default) for the valid parameters.\n\n    Raises:\n        SiteParameterError: If the profile is unknown, if required parameters\n                            are missing, or if provided parameters fail validation\n                            (incorrect type, out of range, or unknown key).\n    \"\"\"\n\n    def __init__(self, profile, **kwargs):\n        dict.__init__(self)\n\n        # Load configuration using pkg_resources (modern approach)\n        # Assumes 'configs' is a python package containing 'site_params.yaml'\n        with pkg_resources.files(configs).joinpath(\"site_params.yaml\").open(\"r\") as f:\n            full_config = yaml.safe_load(f)\n\n        config = full_config[\"wofost\"]\n\n        # Validate Profile\n        if profile not in config[\"profiles\"]:\n            raise SiteParameterError(\n                f\"Unknown profile '{profile}'. Available profiles: {list(config['profiles'].keys())}\"\n            )\n\n        # Load Profile Settings\n        profile_def = config[\"profiles\"][profile]\n        self.valid_param_names = set(profile_def[\"parameters\"])\n        self.required_params = set(profile_def.get(\"required\", []))\n\n        all_param_defs = config[\"site_params\"]\n        self.param_metadata = {\n            param: all_param_defs[param] for param in self.valid_param_names\n        }\n\n        # 1. Process and Validate Parameters\n        for par_name in self.valid_param_names:\n            par_def = all_param_defs[par_name]\n\n            # Determine value: use provided kwarg or fall back to default\n            if par_name in kwargs:\n                value = kwargs.pop(par_name)\n            else:\n                if par_name in self.required_params:\n                    raise SiteParameterError(\n                        f\"Value for parameter '{par_name}' is required for profile '{profile}'!\"\n                    )\n                value = par_def[\"default\"]\n\n            # Convert types and check valid ranges\n            if value is not None:\n                value = self._convert_and_validate(par_name, value, par_def)\n\n            # Store validated value in the dictionary\n            self[par_name] = value\n\n        # 2. Check for Unknown Parameters\n        # Any keys remaining in kwargs are not defined in the profile configuration\n        if kwargs:\n            msg = f\"Unknown parameters provided for profile '{profile}': {list(kwargs.keys())}\"\n            raise SiteParameterError(msg)\n\n    def _convert_and_validate(self, name, value, definition):\n        \"\"\"\n        Internal helper to cast types and validate ranges.\n\n        Args:\n            name (str): The name of the parameter.\n            value (any): The value to validate.\n            definition (dict): The metadata dictionary containing 'type' and 'range'.\n\n        Returns:\n            The value cast to the correct type (int, float, list).\n\n        Raises:\n            SiteParameterError: If type casting fails or value is out of bounds.\n        \"\"\"\n        target_type_str = definition[\"type\"]\n\n        # 1. Type Casting\n        try:\n            if target_type_str == \"int\":\n                value = int(value)\n            elif target_type_str == \"float\":\n                value = float(value)\n            elif target_type_str == \"list\":\n                if not isinstance(value, list):\n                    raise ValueError\n        except (ValueError, TypeError):\n            raise SiteParameterError(\n                f\"Parameter '{name}' must be of type {target_type_str}, got {type(value)}\"\n            )\n\n        # 2. Range Checking\n        valid_range = definition[\"range\"]\n\n        if target_type_str == \"list\":\n            # For lists, validate every element against the range\n            min_val, max_val = valid_range\n            if not all(min_val &lt;= x &lt;= max_val for x in value):\n                raise SiteParameterError(\n                    f\"Elements in list '{name}' must be between {min_val} and {max_val}\"\n                )\n\n        elif target_type_str == \"int\" and valid_range == [0, 1]:\n            # Specific handling for binary flags (0 or 1)\n            if value not in [0, 1]:\n                raise SiteParameterError(f\"Parameter '{name}' must be 0 or 1.\")\n\n        else:\n            # Standard numeric range check [min, max]\n            min_val, max_val = valid_range\n            if not (min_val &lt;= value &lt;= max_val):\n                raise SiteParameterError(\n                    f\"Value {value} for parameter '{name}' out of range [{min_val}, {max_val}]\"\n                )\n\n        return value\n</code></pre>"},{"location":"soil/","title":"soil module","text":"<p>Module to prepare soil data</p>"},{"location":"soil/#cropengine.soil.IsricSoilDataProvider","title":"<code> IsricSoilDataProvider        </code>","text":"<p>Initialize the ISRIC Soil Data Provider.</p> <p>Parameters:</p> Name Type Description Default <code>latitude</code> <code>float</code> <p>The latitude of the location.</p> required <code>longitude</code> <code>float</code> <p>The longitude of the location.</p> required <code>properties</code> <code>list</code> <p>List of soil properties to fetch (e.g., ['clay', 'sand']).                              Defaults to all available in config.</p> <code>None</code> <code>depths</code> <code>list</code> <p>List of depth ranges (e.g., ['0-5cm']).                          Defaults to all available in config.</p> <code>None</code> <code>values</code> <code>list</code> <p>List of statistical values (e.g., ['mean', 'Q0.5']).                          Defaults to all available in config.</p> <code>None</code> <code>filepath</code> <code>str</code> <p>Path to save the resulting CSV file. Defaults to None.</p> <code>None</code> Source code in <code>cropengine/soil.py</code> <pre><code>class IsricSoilDataProvider:\n    \"\"\"\n    Initialize the ISRIC Soil Data Provider.\n\n    Args:\n        latitude (float): The latitude of the location.\n        longitude (float): The longitude of the location.\n        properties (list, optional): List of soil properties to fetch (e.g., ['clay', 'sand']).\n                                         Defaults to all available in config.\n        depths (list, optional): List of depth ranges (e.g., ['0-5cm']).\n                                     Defaults to all available in config.\n        values (list, optional): List of statistical values (e.g., ['mean', 'Q0.5']).\n                                     Defaults to all available in config.\n        filepath (str, optional): Path to save the resulting CSV file. Defaults to None.\n    \"\"\"\n\n    def __init__(\n        self,\n        latitude,\n        longitude,\n        properties=None,\n        depths=None,\n        values=None,\n        filepath=None,\n    ):\n        self.latitude = latitude\n        self.longitude = longitude\n        self.filepath = filepath\n\n        # Internal cache storage\n        self._cached_df = None\n\n        # Load configuration using pkg_resources\n        with pkg_resources.files(configs).joinpath(\"soil.yaml\").open(\"r\") as f:\n            full_config = yaml.safe_load(f)\n\n        self.config = full_config[\"isric_rest_api\"]\n        self.base_url = self.config[\"api\"][\"base_url\"]\n\n        # Validate inputs\n        self.properties = self._validate_input(\n            properties, self.config[\"options\"][\"properties\"], \"Property\"\n        )\n        self.depths = self._validate_input(\n            depths, self.config[\"options\"][\"depths\"], \"Depth\"\n        )\n        self.values = self._validate_input(\n            values, self.config[\"options\"][\"values\"], \"Value\"\n        )\n\n        self.query = {\n            \"lat\": latitude,\n            \"lon\": longitude,\n            \"property\": self.properties,\n            \"depth\": self.depths,\n            \"value\": self.values,\n        }\n\n    def _validate_input(self, user_input, valid_options, category_name):\n        \"\"\"Validates user input against the loaded config options.\"\"\"\n        if user_input is None:\n            return valid_options\n\n        if isinstance(user_input, str):\n            user_input = [user_input]\n\n        # Check for invalid items\n        invalid_items = [item for item in user_input if item not in valid_options]\n\n        if invalid_items:\n            error_msg = (\n                f\"\\nError: Invalid {category_name}(s) provided: {invalid_items}\\n\"\n                f\"Available options in {category_name} are: {valid_options}\"\n            )\n            raise ValueError(error_msg)\n\n        return user_input\n\n    def _extract_data(self):\n        \"\"\"Internal method to hit the API.\"\"\"\n        print(f\"Fetching soil data for {self.latitude}, {self.longitude}...\")\n        try:\n            response = requests.get(self.base_url, params=self.query)\n            response.raise_for_status()\n            return response.json()\n        except Exception as e:\n            print(f\"Error fetching data: {e}\")\n            return None\n\n    def get_data(self):\n        \"\"\"\n        Fetches, parses, and returns soil data.\n        Uses cached memory if data has already been fetched for this instance.\n        \"\"\"\n        # 1. Check Cache (Optimization)\n        if self._cached_df is not None:\n            print(\"Returning cached data (no API call made).\")\n            return self._cached_df\n\n        # 2. Fetch Data\n        raw_data = self._extract_data()\n\n        if not raw_data:\n            return pd.DataFrame()\n\n        rows = []\n        layers = raw_data.get(\"properties\", {}).get(\"layers\", [])\n\n        # 3. Parse Data\n        for layer in layers:\n            prop_name = layer.get(\"name\")\n\n            # Get Unit Transformation details\n            unit_info = layer.get(\"unit_measure\", {})\n            d_factor = unit_info.get(\"d_factor\", 1)\n\n            # Grab both unit labels\n            mapped_unit = unit_info.get(\"mapped_units\", \"unknown\")  # e.g. \"cg/cm\u00b3\"\n            target_unit = unit_info.get(\"target_units\", \"unknown\")  # e.g. \"kg/dm\u00b3\"\n\n            for depth_record in layer.get(\"depths\", []):\n                depth_range = depth_record.get(\"label\")\n                values_dict = depth_record.get(\"values\", {})\n\n                for metric, raw_val in values_dict.items():\n                    # Calculate transformed value\n                    if isinstance(raw_val, (int, float)) and d_factor != 0:\n                        converted_val = raw_val / d_factor\n                    else:\n                        converted_val = raw_val\n\n                    rows.append(\n                        {\n                            \"latitude\": self.latitude,\n                            \"longitude\": self.longitude,\n                            \"property\": prop_name,\n                            \"depth\": depth_range,\n                            \"metric\": metric,\n                            # Raw Data (Integer from API)\n                            \"value\": raw_val,\n                            \"unit\": mapped_unit,\n                            # Transformed Data (Scientific Float)\n                            \"transformed_value\": converted_val,\n                            \"transformed_unit\": target_unit,\n                        }\n                    )\n\n        df = pd.DataFrame(rows)\n\n        # 4. Update Cache\n        self._cached_df = df\n\n        # 5. Save to File (if requested)\n        if self.filepath and not df.empty:\n            try:\n                df.to_csv(self.filepath, index=False)\n                print(f\"Data saved to {self.filepath}\")\n            except Exception as e:\n                print(f\"Failed to save file: {e}\")\n\n        return df\n</code></pre>"},{"location":"soil/#cropengine.soil.IsricSoilDataProvider.get_data","title":"<code>get_data(self)</code>","text":"<p>Fetches, parses, and returns soil data. Uses cached memory if data has already been fetched for this instance.</p> Source code in <code>cropengine/soil.py</code> <pre><code>def get_data(self):\n    \"\"\"\n    Fetches, parses, and returns soil data.\n    Uses cached memory if data has already been fetched for this instance.\n    \"\"\"\n    # 1. Check Cache (Optimization)\n    if self._cached_df is not None:\n        print(\"Returning cached data (no API call made).\")\n        return self._cached_df\n\n    # 2. Fetch Data\n    raw_data = self._extract_data()\n\n    if not raw_data:\n        return pd.DataFrame()\n\n    rows = []\n    layers = raw_data.get(\"properties\", {}).get(\"layers\", [])\n\n    # 3. Parse Data\n    for layer in layers:\n        prop_name = layer.get(\"name\")\n\n        # Get Unit Transformation details\n        unit_info = layer.get(\"unit_measure\", {})\n        d_factor = unit_info.get(\"d_factor\", 1)\n\n        # Grab both unit labels\n        mapped_unit = unit_info.get(\"mapped_units\", \"unknown\")  # e.g. \"cg/cm\u00b3\"\n        target_unit = unit_info.get(\"target_units\", \"unknown\")  # e.g. \"kg/dm\u00b3\"\n\n        for depth_record in layer.get(\"depths\", []):\n            depth_range = depth_record.get(\"label\")\n            values_dict = depth_record.get(\"values\", {})\n\n            for metric, raw_val in values_dict.items():\n                # Calculate transformed value\n                if isinstance(raw_val, (int, float)) and d_factor != 0:\n                    converted_val = raw_val / d_factor\n                else:\n                    converted_val = raw_val\n\n                rows.append(\n                    {\n                        \"latitude\": self.latitude,\n                        \"longitude\": self.longitude,\n                        \"property\": prop_name,\n                        \"depth\": depth_range,\n                        \"metric\": metric,\n                        # Raw Data (Integer from API)\n                        \"value\": raw_val,\n                        \"unit\": mapped_unit,\n                        # Transformed Data (Scientific Float)\n                        \"transformed_value\": converted_val,\n                        \"transformed_unit\": target_unit,\n                    }\n                )\n\n    df = pd.DataFrame(rows)\n\n    # 4. Update Cache\n    self._cached_df = df\n\n    # 5. Save to File (if requested)\n    if self.filepath and not df.empty:\n        try:\n            df.to_csv(self.filepath, index=False)\n            print(f\"Data saved to {self.filepath}\")\n        except Exception as e:\n            print(f\"Failed to save file: {e}\")\n\n    return df\n</code></pre>"},{"location":"soil/#cropengine.soil.WOFOSTSoilParameterProvider","title":"<code> WOFOSTSoilParameterProvider        </code>","text":"<p>Calculates soil physics and chemical parameters required for WOFOST crop modeling using ISRIC SoilGrids data.</p> <p>This class extracts soil properties, estimates hydraulic conductivity using Pedotransfer Functions (Cosby), and fits the Van Genuchten equation.</p> <p>Parameters:</p> Name Type Description Default <code>soil_data</code> <code>pd.DataFrame</code> <p>DataFrame containing ISRIC SoilGrids data.</p> required <code>**kwargs</code> <p>Optional overrides for specific soil parameters.</p> <code>{}</code> Source code in <code>cropengine/soil.py</code> <pre><code>class WOFOSTSoilParameterProvider:\n    \"\"\"\n    Calculates soil physics and chemical parameters required for WOFOST\n    crop modeling using ISRIC SoilGrids data.\n\n    This class extracts soil properties, estimates hydraulic conductivity\n    using Pedotransfer Functions (Cosby), and fits the Van Genuchten\n    equation.\n\n    Args:\n        soil_data (pd.DataFrame): DataFrame containing ISRIC SoilGrids data.\n        **kwargs: Optional overrides for specific soil parameters.\n    \"\"\"\n\n    # Default parameters for potential production\n    _defaults = {\n        \"SMFCF\": 0.3,\n        \"SM0\": 0.4,\n        \"SMW\": 0.1,\n        \"RDMSOL\": 120,\n        \"CRAIRC\": 0.06,\n        \"K0\": 10.0,\n        \"SOPE\": 10.0,\n        \"KSUB\": 10.0,\n    }\n\n    def __init__(self, soil_data, **kwargs):\n\n        self.df = soil_data\n        self.params = {}\n\n        # 1. Load Valid Keys dynamically from YAML\n        self.param_metadata = get_wofost_soil_parameters_metadata()\n        self.valid_keys = set(self.param_metadata.keys())\n\n        # 2. Validate kwargs immediately\n        unknown_keys = [k for k in kwargs.keys() if k not in self.valid_keys]\n        if unknown_keys:\n            raise ValueError(\n                f\"Invalid WOFOST parameters provided: {unknown_keys}. \"\n                \"These keys are not defined in the soil configuration.\"\n            )\n\n        self.overrides = kwargs\n\n        # Specific pF points required by WOFOST/PCSE implementations\n        self.pf_range = np.array(\n            [-1.000, 1.000, 1.300, 1.491, 2.000, 2.400, 2.700, 3.400, 4.204, 6.000]\n        )\n        self.h_range = 10**self.pf_range\n\n    def _get_val(self, prop_name):\n        \"\"\"Helper to safely extract a specific property value from the DataFrame.\"\"\"\n        try:\n            return self.df.loc[self.df[\"property\"] == prop_name, \"value\"].values[0]\n        except IndexError:\n            raise ValueError(f\"Missing required property: {prop_name}\")\n\n    def _calculate_ksat_ptf(self, sand_pct, clay_pct):\n        \"\"\"Estimate Ksat (cm/day) using Cosby (1984) PTF.\"\"\"\n        log_ksat = -0.6 + (0.0126 * sand_pct) - (0.0064 * clay_pct)\n        return max(0.1, min((10**log_ksat) * 24, 500.0))\n\n    def _van_genuchten_theta(self, h, theta_r, alpha, n, theta_s):\n        \"\"\"Mualem-Van Genuchten equation.\"\"\"\n        h = np.maximum(h, 0.0)\n        m = 1 - (1 / n)\n        return theta_r + (theta_s - theta_r) / ((1 + (alpha * h) ** n) ** m)\n\n    def get_params(self):\n        \"\"\"\n        Calculates parameters, fits curves, applies overrides, and returns dictionary.\n        \"\"\"\n        # 1. Extract and Convert Data\n        bdod = self._get_val(\"bdod\") / 100.0\n        soc_g_kg = self._get_val(\"soc\") / 10.0\n        n_g_kg = self._get_val(\"nitrogen\") / 100.0\n        ph = self._get_val(\"phh2o\") / 10.0\n        sand_pct = self._get_val(\"sand\") / 10.0\n        clay_pct = self._get_val(\"clay\") / 10.0\n\n        theta_10 = self._get_val(\"wv0010\") / 1000.0\n        theta_33 = self._get_val(\"wv0033\") / 1000.0\n        theta_1500 = self._get_val(\"wv1500\") / 1000.0\n\n        porosity = 1 - (bdod / 2.65)\n        ksat_est = self._calculate_ksat_ptf(sand_pct, clay_pct)\n\n        # 2. Fit Retention Curve\n        h_obs = np.array([0.01, 100.0, 330.0, 15000.0])\n        theta_obs = np.array([porosity, theta_10, theta_33, theta_1500])\n        p0 = [0.01, 0.01, 1.5]\n        bounds = ([0.0, 1e-5, 1.01], [theta_1500, 10.0, 10.0])\n\n        try:\n            popt, _ = curve_fit(\n                lambda h, tr, a, n: self._van_genuchten_theta(\n                    h, tr, a, n, theta_s=porosity\n                ),\n                h_obs,\n                theta_obs,\n                p0=p0,\n                bounds=bounds,\n                method=\"trf\",\n            )\n            theta_r_opt, alpha_opt, n_opt = popt\n        except Exception as e:\n            print(f\"Scipy fitting failed: {e}. Using default texture-based parameters.\")\n            theta_r_opt, alpha_opt, n_opt = 0.01, 0.01, 1.5\n\n        # 3. Create Pedon Model\n        vg_model = pe.soilmodel.Genuchten(\n            k_s=ksat_est,\n            theta_s=porosity,\n            theta_r=theta_r_opt,\n            alpha=alpha_opt,\n            n=n_opt,\n            l=0.5,\n        )\n\n        # 4. Generate Tables &amp; Scalars\n        theta_curve = vg_model.theta(self.h_range)\n        k_curve = vg_model.k(self.h_range)\n\n        sm_table = []\n        cond_table = []\n        for pf, th, k in zip(self.pf_range, theta_curve, k_curve):\n            sm_table.extend([float(pf), float(th)])\n            k_safe = max(k, 1e-15)\n            cond_table.extend([float(pf), float(np.log10(k_safe))])\n\n        sm0 = vg_model.theta(0.01)\n        smfcf = vg_model.theta(100.0)\n        smw = vg_model.theta(16000.0)\n        crairc = max(0.05, sm0 - smfcf)\n\n        # 5. Chemical Props &amp; Dimensions\n        fsomi = (soc_g_kg * 1.724) / 1000.0\n        cn_ratio = soc_g_kg / n_g_kg if n_g_kg &gt; 0 else 10.0\n\n        depth_str = self.df.iloc[0][\"depth\"]\n        try:\n            top, bottom = depth_str.replace(\"cm\", \"\").split(\"-\")\n            thickness = float(bottom) - float(top)\n        except:\n            thickness = 10.0\n\n        # 6. Construct Final Dictionary\n        self.params = self._defaults.copy()\n\n        # Overwrite with calculated values\n        self.params.update(\n            {\n                \"Soil_pH\": float(round(ph, 3)),\n                \"RHOD\": float(round(bdod, 3)),\n                \"FSOMI\": float(round(fsomi, 3)),\n                \"CNRatioSOMI\": float(round(cn_ratio, 3)),\n                \"Thickness\": float(round(thickness, 3)),\n                \"SM0\": float(round(float(sm0), 3)),\n                \"SMFCF\": float(round(float(smfcf), 3)),\n                \"SMW\": float(round(float(smw), 3)),\n                \"CRAIRC\": float(round(float(crairc), 3)),\n                \"SMfromPF\": [round(x, 3) for x in sm_table],\n                \"CONDfromPF\": [round(x, 3) for x in cond_table],\n            }\n        )\n\n        # 7. Apply Validated Overrides\n        if self.overrides:\n            self.params.update(self.overrides)\n\n        return self.params\n</code></pre>"},{"location":"soil/#cropengine.soil.WOFOSTSoilParameterProvider.get_params","title":"<code>get_params(self)</code>","text":"<p>Calculates parameters, fits curves, applies overrides, and returns dictionary.</p> Source code in <code>cropengine/soil.py</code> <pre><code>def get_params(self):\n    \"\"\"\n    Calculates parameters, fits curves, applies overrides, and returns dictionary.\n    \"\"\"\n    # 1. Extract and Convert Data\n    bdod = self._get_val(\"bdod\") / 100.0\n    soc_g_kg = self._get_val(\"soc\") / 10.0\n    n_g_kg = self._get_val(\"nitrogen\") / 100.0\n    ph = self._get_val(\"phh2o\") / 10.0\n    sand_pct = self._get_val(\"sand\") / 10.0\n    clay_pct = self._get_val(\"clay\") / 10.0\n\n    theta_10 = self._get_val(\"wv0010\") / 1000.0\n    theta_33 = self._get_val(\"wv0033\") / 1000.0\n    theta_1500 = self._get_val(\"wv1500\") / 1000.0\n\n    porosity = 1 - (bdod / 2.65)\n    ksat_est = self._calculate_ksat_ptf(sand_pct, clay_pct)\n\n    # 2. Fit Retention Curve\n    h_obs = np.array([0.01, 100.0, 330.0, 15000.0])\n    theta_obs = np.array([porosity, theta_10, theta_33, theta_1500])\n    p0 = [0.01, 0.01, 1.5]\n    bounds = ([0.0, 1e-5, 1.01], [theta_1500, 10.0, 10.0])\n\n    try:\n        popt, _ = curve_fit(\n            lambda h, tr, a, n: self._van_genuchten_theta(\n                h, tr, a, n, theta_s=porosity\n            ),\n            h_obs,\n            theta_obs,\n            p0=p0,\n            bounds=bounds,\n            method=\"trf\",\n        )\n        theta_r_opt, alpha_opt, n_opt = popt\n    except Exception as e:\n        print(f\"Scipy fitting failed: {e}. Using default texture-based parameters.\")\n        theta_r_opt, alpha_opt, n_opt = 0.01, 0.01, 1.5\n\n    # 3. Create Pedon Model\n    vg_model = pe.soilmodel.Genuchten(\n        k_s=ksat_est,\n        theta_s=porosity,\n        theta_r=theta_r_opt,\n        alpha=alpha_opt,\n        n=n_opt,\n        l=0.5,\n    )\n\n    # 4. Generate Tables &amp; Scalars\n    theta_curve = vg_model.theta(self.h_range)\n    k_curve = vg_model.k(self.h_range)\n\n    sm_table = []\n    cond_table = []\n    for pf, th, k in zip(self.pf_range, theta_curve, k_curve):\n        sm_table.extend([float(pf), float(th)])\n        k_safe = max(k, 1e-15)\n        cond_table.extend([float(pf), float(np.log10(k_safe))])\n\n    sm0 = vg_model.theta(0.01)\n    smfcf = vg_model.theta(100.0)\n    smw = vg_model.theta(16000.0)\n    crairc = max(0.05, sm0 - smfcf)\n\n    # 5. Chemical Props &amp; Dimensions\n    fsomi = (soc_g_kg * 1.724) / 1000.0\n    cn_ratio = soc_g_kg / n_g_kg if n_g_kg &gt; 0 else 10.0\n\n    depth_str = self.df.iloc[0][\"depth\"]\n    try:\n        top, bottom = depth_str.replace(\"cm\", \"\").split(\"-\")\n        thickness = float(bottom) - float(top)\n    except:\n        thickness = 10.0\n\n    # 6. Construct Final Dictionary\n    self.params = self._defaults.copy()\n\n    # Overwrite with calculated values\n    self.params.update(\n        {\n            \"Soil_pH\": float(round(ph, 3)),\n            \"RHOD\": float(round(bdod, 3)),\n            \"FSOMI\": float(round(fsomi, 3)),\n            \"CNRatioSOMI\": float(round(cn_ratio, 3)),\n            \"Thickness\": float(round(thickness, 3)),\n            \"SM0\": float(round(float(sm0), 3)),\n            \"SMFCF\": float(round(float(smfcf), 3)),\n            \"SMW\": float(round(float(smw), 3)),\n            \"CRAIRC\": float(round(float(crairc), 3)),\n            \"SMfromPF\": [round(x, 3) for x in sm_table],\n            \"CONDfromPF\": [round(x, 3) for x in cond_table],\n        }\n    )\n\n    # 7. Apply Validated Overrides\n    if self.overrides:\n        self.params.update(self.overrides)\n\n    return self.params\n</code></pre>"},{"location":"soil/#cropengine.soil.get_wofost_soil_parameters_metadata","title":"<code>get_wofost_soil_parameters_metadata()</code>","text":"<p>Parses 'configs/soil_params.yaml' to extract soil parameter definitions.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of parameters with 'description' and 'unit'.</p> Source code in <code>cropengine/soil.py</code> <pre><code>def get_wofost_soil_parameters_metadata():\n    \"\"\"\n    Parses 'configs/soil_params.yaml' to extract soil parameter definitions.\n\n    Returns:\n        dict: Dictionary of parameters with 'description' and 'unit'.\n    \"\"\"\n    metadata = {}\n\n    try:\n        with pkg_resources.files(configs).joinpath(\"soil_params.yaml\").open(\"r\") as f:\n            full_config = yaml.safe_load(f)\n    except (FileNotFoundError, ModuleNotFoundError) as e:\n        raise ValueError(\n            f\"Could not load 'soil_params.yaml' from 'configs'. Error: {e}\"\n        )\n    except yaml.YAMLError as exc:\n        raise ValueError(f\"Error parsing YAML content: {exc}\")\n\n    # Locate the root soil parameters section\n    soil_section = full_config.get(\"wofost\", {}).get(\"soil_params\", {})\n\n    if not soil_section:\n        if \"WaterbalanceFD\" in full_config or \"WaterBalanceLayered\" in full_config:\n            soil_section = full_config\n        else:\n            return {}\n\n    def _recursive_extract(node):\n        for key, value in node.items():\n            if isinstance(value, dict):\n                if \"description\" in value or \"unit\" in value:\n                    metadata[key] = {\n                        \"description\": value.get(\n                            \"description\", \"No description available\"\n                        ),\n                        \"unit\": value.get(\"unit\", \"-\"),\n                    }\n                else:\n                    _recursive_extract(value)\n\n    _recursive_extract(soil_section)\n\n    # Ensure defaults exist\n    if \"K0\" not in metadata:\n        metadata[\"K0\"] = {\n            \"description\": \"Hydraulic conductivity of saturated soil\",\n            \"unit\": \"cm/day\",\n        }\n    if \"IVINF\" not in metadata:\n        metadata[\"IVINF\"] = {\"description\": \"Infiltration limiter\", \"unit\": \"-\"}\n\n    return metadata\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use cropengine in a project:</p> <pre><code>import cropengine\n</code></pre>"},{"location":"weather/","title":"weather module","text":"<p>Module to prepare weather data</p>"},{"location":"weather/#cropengine.weather.ClimateConfig","title":"<code> ClimateConfig        </code>","text":"<p>Parses and holds configuration for climate variables.</p> Source code in <code>cropengine/weather.py</code> <pre><code>class ClimateConfig:\n    \"\"\"Parses and holds configuration for climate variables.\"\"\"\n\n    def __init__(self, config_dict):\n        self.raw = config_dict\n        self.variables = config_dict[\"variables\"]\n        self.all_bands = []\n        self.var_to_bands = {}\n        self.var_to_units = {}\n        self.var_to_conversion = {}\n        self.derived = set()\n        self._parse_variables()\n\n    def _parse_variables(self):\n        for var_name, info in self.variables.items():\n            self.var_to_units[var_name] = (\n                info.get(\"native_unit\"),\n                info.get(\"target_unit\"),\n            )\n            self.var_to_conversion[var_name] = info.get(\"conversion\")\n            if info.get(\"derived\", False):\n                self.derived.add(var_name)\n\n            bands = []\n            for key, value in info.items():\n                if key.startswith(\"band\") and value is not None:\n                    bands.append(value)\n                    self.all_bands.append(value)\n            self.var_to_bands[var_name] = bands\n\n    def get_all_bands(self):\n        return list(set(self.all_bands))\n\n    def is_derived(self, var_name):\n        return var_name in self.derived\n</code></pre>"},{"location":"weather/#cropengine.weather.GEEWeatherDataProvider","title":"<code> GEEWeatherDataProvider        </code>","text":"<p>Handles data retrieval, processing, and export of weather data from Google Earth Engine in PCSE format.</p> <p>IMPORTANT: This class strictly handles POINT data. If a Geometry/Polygon is provided, it extracts data for the CENTROID of that geometry only.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>str</code> <p>Start date (YYYY-MM-DD).</p> required <code>end_date</code> <code>str</code> <p>End date (YYYY-MM-DD).</p> required <code>latitude</code> <code>float</code> <p>Latitude (if geometry not provided).</p> <code>None</code> <code>longitude</code> <code>float</code> <p>Longitude (if geometry not provided).</p> <code>None</code> <code>geometry</code> <code>ee.Geometry</code> <p>Polygon or geometry object. Will be converted to its Centroid.</p> <code>None</code> <code>source</code> <code>str</code> <p>Key in meteo.yaml (e.g., 'era5_land').</p> <code>'era5_land'</code> <code>filepath</code> <code>str</code> <p>Default output path.</p> <code>None</code> <code>ee_project</code> <code>str</code> <p>GCloud project ID for GEE initialization.</p> <code>None</code> <code>**site_kwargs</code> <p>Extra metadata for the Excel header (e.g., Station, Country).</p> <code>{}</code> Source code in <code>cropengine/weather.py</code> <pre><code>class GEEWeatherDataProvider:\n    \"\"\"\n    Handles data retrieval, processing, and export of weather data from Google Earth Engine in PCSE format.\n\n    IMPORTANT: This class strictly handles POINT data. If a Geometry/Polygon is provided,\n    it extracts data for the CENTROID of that geometry only.\n\n    Args:\n        start_date (str): Start date (YYYY-MM-DD).\n        end_date (str): End date (YYYY-MM-DD).\n        latitude (float, optional): Latitude (if geometry not provided).\n        longitude (float, optional): Longitude (if geometry not provided).\n        geometry (ee.Geometry, optional): Polygon or geometry object. Will be converted to its Centroid.\n        source (str): Key in meteo.yaml (e.g., 'era5_land').\n        filepath (str, optional): Default output path.\n        ee_project (str, optional): GCloud project ID for GEE initialization.\n        **site_kwargs: Extra metadata for the Excel header (e.g., Station, Country).\n    \"\"\"\n\n    def __init__(\n        self,\n        start_date,\n        end_date,\n        latitude=None,\n        longitude=None,\n        geometry=None,\n        source=\"era5_land\",\n        filepath=None,\n        ee_project=None,\n        **site_kwargs,\n    ):\n\n        self._check_gee_initialized(ee_project)\n\n        if geometry:\n            if isinstance(geometry, (ee.Feature, ee.FeatureCollection)):\n                region_geom = geometry.geometry()\n            else:\n                region_geom = ee.Geometry(geometry)\n\n            # Calculate Centroid\n            try:\n                centroid_obj = region_geom.centroid(maxError=1)\n                coords = centroid_obj.coordinates().getInfo()\n            except Exception:\n                centroid_obj = region_geom.bounds(maxError=1).centroid(maxError=1)\n                coords = centroid_obj.coordinates().getInfo()\n\n            self.longitude = coords[0]\n            self.latitude = coords[1]\n\n        elif latitude is not None and longitude is not None:\n            self.latitude = latitude\n            self.longitude = longitude\n        else:\n            raise ValueError(\n                \"Must provide either 'geometry' OR 'latitude' and 'longitude'.\"\n            )\n\n        self.region = ee.Geometry.Point([self.longitude, self.latitude])\n\n        self.start_date = start_date\n        self.end_date = end_date\n        self.source = source.lower()\n        self.filepath = filepath\n        self.site_kwargs = site_kwargs\n\n        self._cached_df = None\n        self._cached_elevation = None\n\n        with pkg_resources.files(configs).joinpath(\"meteo.yaml\").open(\"r\") as f:\n            full_config = yaml.safe_load(f)\n\n        if source.lower() not in full_config:\n            raise ValueError(\n                f\"Source '{source}' not found. Available: {list(full_config.keys())}\"\n            )\n\n        self.weather_config = full_config[source.lower()]\n        self.cfg = ClimateConfig(self.weather_config)\n\n    def _check_gee_initialized(self, project=None):\n        \"\"\"\n        Checks if GEE is initialized. If not, attempts to initialize.\n        \"\"\"\n        try:\n            ee.Image(0).getInfo()\n        except Exception:\n            print(\"GEE not initialized. Attempting initialization...\")\n            try:\n                # Try initializing with specific project if provided, else default\n                if project:\n                    ee.Initialize(project=project)\n                else:\n                    ee.Initialize()\n                print(\"GEE Initialized successfully.\")\n            except Exception as e:\n                raise RuntimeError(\n                    f\"Failed to initialize Earth Engine: {e}.\\n\"\n                    \"Please run 'earthengine authenticate' in your terminal first.\"\n                )\n\n    def _get_elevation(self):\n\n        if self._cached_elevation is not None:\n            return self._cached_elevation\n\n        try:\n            geom = self.region\n            dem_source = self.weather_config.get(\n                \"dem_source\", \"projects/sat-io/open-datasets/GLO-30\"\n            )\n\n            elev = (\n                ee.ImageCollection(dem_source)\n                .filterBounds(geom)\n                .first()\n                .sample(geom, scale=30)\n                .first()\n                .get(\"b1\")\n            )\n\n            val = elev.getInfo()\n            self._cached_elevation = round(float(val), 3) if val is not None else 0.0\n            return self._cached_elevation\n\n        except Exception as e:\n            print(f\"Warning: Could not fetch elevation ({e}). Defaulting to 0.\")\n            self._cached_elevation = 0.0\n            return 0.0\n\n    def _extract_data(self):\n        \"\"\"\n        Extraction of weather data.\n        \"\"\"\n        band_names = self.cfg.get_all_bands()\n        scale = self.weather_config.get(\"default_scale\", 5000)\n        collection_id = self.weather_config.get(\"collection\")\n\n        ic = ee.ImageCollection(collection_id)\n\n        return extract_timeseries_to_point(\n            lat=self.latitude,\n            lon=self.longitude,\n            image_collection=ic,\n            start_date=self.start_date,\n            end_date=self.end_date,\n            band_names=band_names,\n            scale=scale,\n        )\n\n    def get_data(self):\n        if self._cached_df is not None:\n            return self._cached_df\n\n        df_raw = self._extract_data()\n        output = pd.DataFrame(index=df_raw.index)\n        output[\"date\"] = df_raw[\"time\"]\n\n        for var, bands in self.cfg.var_to_bands.items():\n            conversion = self.cfg.var_to_conversion.get(var)\n            converter_func = CONVERSION_FUNCS.get(conversion, lambda x: x)\n\n            inputs = [df_raw[b] for b in bands]\n\n            try:\n                output[var] = converter_func(*inputs)\n            except TypeError as e:\n                raise ValueError(\n                    f\"Error calculating {var}: Function '{conversion}' \"\n                    f\"expected different arguments than provided bands {bands}. \"\n                    f\"Details: {e}\"\n                )\n\n        self._cached_df = output.round(3)\n        return self._cached_df\n\n    def save_weather_excel(self, filepath=None, **override_kwargs):\n        target_path = filepath or self.filepath\n        if not target_path:\n            raise ValueError(\"Invalid filepath.\")\n\n        df = self.get_data()\n\n        meta_defaults = {\n            \"Country\": \"Unknown\",\n            \"Station\": \"Unknown\",\n            \"Description\": self.weather_config.get(\"description\"),\n            \"Source\": self.weather_config.get(\"collection\"),\n            \"Contact\": \"Unknown\",\n            \"Missing values\": -999,\n            \"AngstromA\": 0.25,\n            \"AngstromB\": 0.50,\n            \"HasSunshine\": False,\n        }\n\n        meta = {**meta_defaults, **self.site_kwargs, **override_kwargs}\n\n        excel_rows = []\n\n        excel_rows.append([\"Site Characteristics\"])\n        excel_rows.append([\"Country\", meta[\"Country\"]])\n        excel_rows.append([\"Station\", meta[\"Station\"]])\n        excel_rows.append([\"Description\", meta[\"Description\"]])\n        excel_rows.append([\"Source\", meta[\"Source\"]])\n        excel_rows.append([\"Contact\", meta[\"Contact\"]])\n        excel_rows.append([\"Missing values\", meta[\"Missing values\"]])\n\n        excel_rows.append(\n            [\n                \"Longitude\",\n                \"Latitude\",\n                \"Elevation\",\n                \"AngstromA\",\n                \"AngstromB\",\n                \"HasSunshine\",\n            ]\n        )\n        excel_rows.append(\n            [\n                self.longitude,\n                self.latitude,\n                self._get_elevation(),\n                meta[\"AngstromA\"],\n                meta[\"AngstromB\"],\n                str(meta[\"HasSunshine\"]).upper(),\n            ]\n        )\n\n        excel_rows.append([\"Observed data\"])\n\n        var_order = [\"IRRAD\", \"TMIN\", \"TMAX\", \"VAP\", \"WIND\", \"RAIN\", \"SNOWDEPTH\"]\n        present_vars = [v for v in var_order if v in df.columns]\n\n        header_names = [\"DAY\"] + present_vars\n        excel_rows.append(header_names)\n\n        header_units = [\"date\"]\n        for v in present_vars:\n            if v in self.cfg.var_to_units:\n                header_units.append(self.cfg.var_to_units[v][1])\n            else:\n                header_units.append(\"-\")\n        excel_rows.append(header_units)\n\n        df_export = df.copy()\n        df_export = df_export.fillna(meta[\"Missing values\"])\n        df_export = df_export[[\"date\"] + present_vars]\n\n        with pd.ExcelWriter(target_path, engine=\"openpyxl\") as writer:\n            pd.DataFrame(excel_rows).to_excel(\n                writer, sheet_name=\"Sheet1\", index=False, header=False, startrow=0\n            )\n\n            df_export.to_excel(\n                writer,\n                sheet_name=\"Sheet1\",\n                index=False,\n                header=False,\n                startrow=len(excel_rows),\n            )\n\n        print(f\"File saved successfully to {target_path}\")\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[\u00a0]: Copied! <pre>print(\"Hello World!\")\n</pre> print(\"Hello World!\")"},{"location":"examples/site/","title":"Site","text":"In\u00a0[\u00a0]: Copied! <pre>from cropengine.site import WOFOSTSiteParametersProvider\n</pre> from cropengine.site import WOFOSTSiteParametersProvider In\u00a0[\u00a0]: Copied! <pre>site_param_provider = WOFOSTSiteParametersProvider(\"WOFOST72\", **{\"WAV\": 10})\n</pre> site_param_provider = WOFOSTSiteParametersProvider(\"WOFOST72\", **{\"WAV\": 10}) In\u00a0[\u00a0]: Copied! <pre>dict(site_param_provider)\n</pre> dict(site_param_provider) In\u00a0[\u00a0]: Copied! <pre>site_param_provider.param_metadata\n</pre> site_param_provider.param_metadata"},{"location":"examples/soil/","title":"Soil","text":"In\u00a0[\u00a0]: Copied! <pre>from cropengine.soil import IsricSoilDataProvider, WOFOSTSoilParameterProvider\n</pre> from cropengine.soil import IsricSoilDataProvider, WOFOSTSoilParameterProvider In\u00a0[\u00a0]: Copied! <pre>soil_data_provider = IsricSoilDataProvider(\n    latitude=52.53,\n    longitude=14.12,\n    properties=[\n        \"bdod\",\n        \"cec\",\n        \"cfvo\",\n        \"clay\",\n        \"nitrogen\",\n        \"ocd\",\n        \"ocs\",\n        \"phh2o\",\n        \"sand\",\n        \"silt\",\n        \"soc\",\n        \"wv0010\",\n        \"wv0033\",\n        \"wv1500\",\n    ],\n    depths=[\"0-5cm\"],\n    values=\"mean\",\n)\nsoil_data = soil_data_provider.get_data()\nprint(soil_data.shape)\nsoil_data.head()\n</pre> soil_data_provider = IsricSoilDataProvider(     latitude=52.53,     longitude=14.12,     properties=[         \"bdod\",         \"cec\",         \"cfvo\",         \"clay\",         \"nitrogen\",         \"ocd\",         \"ocs\",         \"phh2o\",         \"sand\",         \"silt\",         \"soc\",         \"wv0010\",         \"wv0033\",         \"wv1500\",     ],     depths=[\"0-5cm\"],     values=\"mean\", ) soil_data = soil_data_provider.get_data() print(soil_data.shape) soil_data.head() In\u00a0[\u00a0]: Copied! <pre># Calculate soil parameters\ncalc = WOFOSTSoilParameterProvider(soil_data, **{\"SSI\": 10})\npcse_soil_params = calc.get_params()\nprint(pcse_soil_params)\n</pre> # Calculate soil parameters calc = WOFOSTSoilParameterProvider(soil_data, **{\"SSI\": 10}) pcse_soil_params = calc.get_params() print(pcse_soil_params) In\u00a0[\u00a0]: Copied! <pre>calc.param_metadata\n</pre> calc.param_metadata"},{"location":"examples/weather/","title":"Weather","text":"In\u00a0[\u00a0]: Copied! <pre>from cropengine.weather import GEEWeatherDataProvider\n</pre> from cropengine.weather import GEEWeatherDataProvider In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap\n\nee.Initialize()\n</pre> import ee import geemap  ee.Initialize() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(basemap=\"SATELLITE\")\nMap\n</pre> Map = geemap.Map(basemap=\"SATELLITE\") Map In\u00a0[\u00a0]: Copied! <pre>region = Map.draw_last_feature\n</pre> region = Map.draw_last_feature In\u00a0[\u00a0]: Copied! <pre># climdata = GEEWeatherDataProvider(latitude=52.06912171608079, longitude=10.881185799808796, start_date='2020-01-01', end_date='2022-12-31', source='era5_land')\nclimdata_region = GEEWeatherDataProvider(\n    geometry=region,\n    reducer=\"mean\",\n    start_date=\"2020-01-01\",\n    end_date=\"2022-12-31\",\n    source=\"era5_land\",\n)\n</pre> # climdata = GEEWeatherDataProvider(latitude=52.06912171608079, longitude=10.881185799808796, start_date='2020-01-01', end_date='2022-12-31', source='era5_land') climdata_region = GEEWeatherDataProvider(     geometry=region,     reducer=\"mean\",     start_date=\"2020-01-01\",     end_date=\"2022-12-31\",     source=\"era5_land\", ) In\u00a0[\u00a0]: Copied! <pre>climdata.get_data()\n</pre> climdata.get_data() In\u00a0[\u00a0]: Copied! <pre># climdata_region.save_weather_excel('data.xlsx')\n</pre> # climdata_region.save_weather_excel('data.xlsx') In\u00a0[\u00a0]: Copied! <pre>import requests\n\n\ndef fetch_soilgrids_data(lat, lon):\n    \"\"\"\n    Fetches specific SoilGrids v2.0 data for WOFOST/PCSE.\n    Mirrors the 'fetchSoilGrids' R function logic.\n    \"\"\"\n\n    # 1. Define the Endpoint\n    base_url = \"https://rest.isric.org/soilgrids/v2.0/properties/query\"\n\n    # 2. Define the Parameters (mapping from your R snippet)\n    # Note: 'wv' variables = Volumetric Water Content (Standard V2.0 properties)\n    params = {\n        \"lat\": lat,\n        \"lon\": lon,\n        \"depth\": [\"0-5cm\", \"5-15cm\", \"15-30cm\", \"30-60cm\", \"60-100cm\"],\n        \"property\": [\n            \"bdod\",  # Bulk Density (cg/cm3)\n            \"clay\",  # Clay (g/kg)\n            \"sand\",  # Sand (g/kg)\n            \"soc\",  # Soil Organic Carbon (dg/kg)\n            \"wv0010\",  # Water Content at 10kPa (Volume %)\n            \"wv0033\",  # Water Content at 33kPa (Volume %) -&gt; Field Capacity\n            \"wv1500\",  # Water Content at 1500kPa (Volume %) -&gt; Wilting Point\n        ],\n        \"value\": \"mean\",  # equivalent to summary_type='mean'\n    }\n\n    # 3. Make the Request\n    print(f\"Fetching data for {lat}, {lon}...\")\n    response = requests.get(base_url, params=params)\n\n    if response.status_code != 200:\n        print(f\"Error: {response.status_code}\")\n        return None\n\n    data = response.json()\n\n    # 4. Parse the complex JSON structure into a simple dictionary\n    # We want to average the top 3 layers (0-30cm) for the crop model\n    target_depths = [\"0-5cm\", \"5-15cm\", \"15-30cm\"]\n    parsed_data = {}\n\n    for layer in data[\"properties\"][\"layers\"]:\n        prop_name = layer[\"name\"]\n\n        # Collect values for the relevant depths\n        values = [\n            d[\"values\"][\"mean\"]\n            for d in layer[\"depths\"]\n            if d[\"label\"] in target_depths and d[\"values\"][\"mean\"] is not None\n        ]\n\n        if values:\n            avg_value = sum(values) / len(values)\n            parsed_data[prop_name] = avg_value\n        else:\n            parsed_data[prop_name] = None\n\n    return parsed_data\n\n\n# --- USAGE ---\n# Example coordinates (Wageningen, NL)\nsoil_data = fetch_soilgrids_data(lat=51.99747, lon=12.16551)\nprint(\"Fetched Data (Raw Units):\")\nprint(soil_data)\n</pre> import requests   def fetch_soilgrids_data(lat, lon):     \"\"\"     Fetches specific SoilGrids v2.0 data for WOFOST/PCSE.     Mirrors the 'fetchSoilGrids' R function logic.     \"\"\"      # 1. Define the Endpoint     base_url = \"https://rest.isric.org/soilgrids/v2.0/properties/query\"      # 2. Define the Parameters (mapping from your R snippet)     # Note: 'wv' variables = Volumetric Water Content (Standard V2.0 properties)     params = {         \"lat\": lat,         \"lon\": lon,         \"depth\": [\"0-5cm\", \"5-15cm\", \"15-30cm\", \"30-60cm\", \"60-100cm\"],         \"property\": [             \"bdod\",  # Bulk Density (cg/cm3)             \"clay\",  # Clay (g/kg)             \"sand\",  # Sand (g/kg)             \"soc\",  # Soil Organic Carbon (dg/kg)             \"wv0010\",  # Water Content at 10kPa (Volume %)             \"wv0033\",  # Water Content at 33kPa (Volume %) -&gt; Field Capacity             \"wv1500\",  # Water Content at 1500kPa (Volume %) -&gt; Wilting Point         ],         \"value\": \"mean\",  # equivalent to summary_type='mean'     }      # 3. Make the Request     print(f\"Fetching data for {lat}, {lon}...\")     response = requests.get(base_url, params=params)      if response.status_code != 200:         print(f\"Error: {response.status_code}\")         return None      data = response.json()      # 4. Parse the complex JSON structure into a simple dictionary     # We want to average the top 3 layers (0-30cm) for the crop model     target_depths = [\"0-5cm\", \"5-15cm\", \"15-30cm\"]     parsed_data = {}      for layer in data[\"properties\"][\"layers\"]:         prop_name = layer[\"name\"]          # Collect values for the relevant depths         values = [             d[\"values\"][\"mean\"]             for d in layer[\"depths\"]             if d[\"label\"] in target_depths and d[\"values\"][\"mean\"] is not None         ]          if values:             avg_value = sum(values) / len(values)             parsed_data[prop_name] = avg_value         else:             parsed_data[prop_name] = None      return parsed_data   # --- USAGE --- # Example coordinates (Wageningen, NL) soil_data = fetch_soilgrids_data(lat=51.99747, lon=12.16551) print(\"Fetched Data (Raw Units):\") print(soil_data) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"}]}